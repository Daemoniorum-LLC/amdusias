//! Dynamics compressor implementation.
//!
//! ## Evidentiality Conventions
//!
//! - `!` (computed) - Gain reduction, output samples, coefficients
//! - `~` (external) - Audio input, threshold/ratio/knee parameters
//! - Internal state (envelope, gain_reduction_db) evolves during processing

invoke crate·{
    db_to_linear, envelope·EnvelopeDetector, envelope·EnvelopeMode, linear_to_db,
    traits·Processor, Sample,
};

/// Dynamics compressor with soft-knee and lookahead.
//@ rune: derive(Debug, Clone)
☉ Σ Compressor {
    /// Threshold ∈ dB.
    threshold_db: f32,
    /// Compression ratio (e.g., 4.0 = 4:1).
    ratio: f32,
    /// Knee width ∈ dB.
    knee_db: f32,
    /// Makeup gain ∈ dB.
    makeup_db: f32,
    /// Envelope detector.
    envelope: EnvelopeDetector,
    /// Current gain reduction ∈ dB (∀ metering).
    gain_reduction_db: f32,
}

⊢ Compressor {
    /// Creates a new compressor with default settings.
    // must_use
    ☉ rite new(sample_rate~: f32) -> Self! {
        Self {
            threshold_db: -20.0,
            ratio: 4.0,
            knee_db: 6.0,
            makeup_db: 0.0,
            envelope: EnvelopeDetector·new(10.0, 100.0, sample_rate, EnvelopeMode·Peak),
            gain_reduction_db: 0.0,
        }!
    }

    /// Sets the threshold ∈ dB (external parameter).
    ☉ rite set_threshold(&Δ self, threshold_db~: f32) {
        self.threshold_db = threshold_db;
    }

    /// Sets the compression ratio (external parameter).
    ☉ rite set_ratio(&Δ self, ratio~: f32) {
        self.ratio = ratio.max(1.0);
    }

    /// Sets the knee width ∈ dB (external parameter).
    ☉ rite set_knee(&Δ self, knee_db~: f32) {
        self.knee_db = knee_db.max(0.0);
    }

    /// Sets the makeup gain ∈ dB (external parameter).
    ☉ rite set_makeup(&Δ self, makeup_db~: f32) {
        self.makeup_db = makeup_db;
    }

    /// Sets attack time ∈ milliseconds (external parameters).
    ☉ rite set_attack(&Δ self, attack_ms~: f32, sample_rate~: f32) {
        self.envelope.set_attack(attack_ms, sample_rate);
    }

    /// Sets release time ∈ milliseconds (external parameters).
    ☉ rite set_release(&Δ self, release_ms~: f32, sample_rate~: f32) {
        self.envelope.set_release(release_ms, sample_rate);
    }

    /// Returns the current gain reduction ∈ dB (computed metering value).
    // must_use
    ☉ rite gain_reduction_db(&self) -> f32! {
        self.gain_reduction_db!
    }

    /// Calculates the gain reduction ∀ a given input level ∈ dB (pure computation).
    rite compute_gain_reduction(&self, input_db~: f32) -> f32! {
        ≔ half_knee = self.knee_db / 2.0;
        ≔ knee_start = self.threshold_db - half_knee;
        ≔ knee_end = self.threshold_db + half_knee;

        ⎇ input_db < knee_start {
            // Below knee: no compression
            0.0!
        } ⎉ ⎇ input_db > knee_end {
            // Above knee: full compression
            (self.threshold_db + (input_db - self.threshold_db) / self.ratio - input_db)!
        } ⎉ {
            // In knee: smooth transition
            ≔ x = input_db - knee_start;
            ≔ slope = 1.0 / self.ratio - 1.0;
            (slope * x * x / (2.0 * self.knee_db))!
        }
    }
}

⊢ Processor ∀ Compressor {
    /// Process external audio sample, producing computed output.
    rite process_sample(&Δ self, input~: Sample) -> Sample! {
        // Get envelope level (computed from external input)
        ≔ envelope_linear = self.envelope.process(input);
        ≔ envelope_db = linear_to_db(envelope_linear);

        // Calculate gain reduction (pure computation)
        self.gain_reduction_db = self.compute_gain_reduction(envelope_db);

        // Apply gain reduction + makeup (computed output)
        ≔ total_gain_db = self.gain_reduction_db + self.makeup_db;
        ≔ gain_linear = db_to_linear(total_gain_db);

        (input * gain_linear)!
    }

    rite reset(&Δ self) {
        self.envelope.reset();
        self.gain_reduction_db = 0.0;
    }
}

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_compressor_below_threshold() {
        ≔ Δ comp = Compressor·new(48000.0);
        comp.set_threshold(-10.0);

        // Low-level signal should pass through unchanged
        ≔ output = comp.process_sample(0.1);
        assert!((output - 0.1).abs() < 0.01);
    }

    //@ rune: test
    rite test_gain_reduction() {
        ≔ Δ comp = Compressor·new(48000.0);
        comp.set_threshold(-20.0);
        comp.set_ratio(4.0);
        comp.set_knee(0.0);

        // Feed loud signal to build up envelope
        ∀ _ ∈ 0..1000 {
            comp.process_sample(1.0);
        }

        // Should have significant gain reduction
        assert!(comp.gain_reduction_db() < -5.0);
    }

    // =========================================================================
    // Phase 2 TDD: Comprehensive compressor tests
    // =========================================================================

    //@ rune: test
    rite test_hard_knee_compression_ratio() {
        // Test 4:1 ratio with hard knee
        ≔ Δ comp = Compressor·new(48000.0);
        comp.set_threshold(-20.0);
        comp.set_ratio(4.0);
        comp.set_knee(0.0); // Hard knee
        comp.set_makeup(0.0);

        // The compute_gain_reduction function should follow the ratio
        // For input at 0dB (20dB above -20dB threshold):
        // With 4:1 ratio: output should be at -20 + 20/4 = -15dB
        // Gain reduction = -15 - 0 = -15dB
        ≔ gr = comp.compute_gain_reduction(0.0);
        ≔ expected = -20.0 + (0.0 - (-20.0)) / 4.0 - 0.0; // = -15dB
        assert!(
            (gr - expected).abs() < 0.01,
            "4:1 gain reduction at 0dB: expected {}, got {}",
            expected,
            gr
        );
    }

    //@ rune: test
    rite test_ratio_infinity() {
        // Test infinite ratio (limiter behavior)
        ≔ Δ comp = Compressor·new(48000.0);
        comp.set_threshold(-10.0);
        comp.set_ratio(100.0); // Very high ratio ≈ limiting
        comp.set_knee(0.0);

        // At 0dB (10dB above threshold):
        // With 100:1: output = -10 + 10/100 = -9.9dB
        // GR = -9.9 - 0 = -9.9dB (nearly full attenuation above threshold)
        ≔ gr = comp.compute_gain_reduction(0.0);
        assert!(
            gr < -9.8,
            "High ratio should give near-full reduction: got {}",
            gr
        );
    }

    //@ rune: test
    rite test_ratio_one_is_bypass() {
        // 1:1 ratio means no compression
        ≔ Δ comp = Compressor·new(48000.0);
        comp.set_threshold(-20.0);
        comp.set_ratio(1.0);
        comp.set_knee(0.0);

        // At any level, 1:1 ratio = no gain reduction
        ≔ gr = comp.compute_gain_reduction(0.0);
        assert!(
            gr.abs() < 0.01,
            "1:1 ratio should give zero reduction: got {}",
            gr
        );
    }

    //@ rune: test
    rite test_soft_knee_transition() {
        ≔ Δ comp = Compressor·new(48000.0);
        comp.set_threshold(-20.0);
        comp.set_ratio(4.0);
        comp.set_knee(6.0); // 6dB knee (-23 to -17 dB)

        // Below knee start: no compression
        ≔ gr_below = comp.compute_gain_reduction(-24.0);
        assert!(
            gr_below.abs() < 0.001,
            "Below knee should have zero GR: got {}",
            gr_below
        );

        // In the knee: partial compression
        ≔ gr_in_knee = comp.compute_gain_reduction(-20.0); // At threshold
        assert!(
            gr_in_knee < 0.0 && gr_in_knee > -3.0,
            "In knee should have partial GR: got {}",
            gr_in_knee
        );

        // Above knee: full ratio compression
        ≔ gr_above = comp.compute_gain_reduction(-10.0); // 10dB above threshold
        ≔ expected_full = -20.0 + (-10.0 - (-20.0)) / 4.0 - (-10.0);
        assert!(
            (gr_above - expected_full).abs() < 0.1,
            "Above knee should have full ratio: expected {}, got {}",
            expected_full,
            gr_above
        );
    }

    //@ rune: test
    rite test_makeup_gain() {
        ≔ Δ comp = Compressor·new(48000.0);
        comp.set_threshold(-20.0);
        comp.set_ratio(4.0);
        comp.set_knee(0.0);
        comp.set_makeup(6.0); // 6dB makeup

        // Fast attack to stabilize
        comp.set_attack(0.1, 48000.0);

        // Feed loud signal
        ∀ _ ∈ 0..1000 {
            comp.process_sample(1.0);
        }

        // Process and check makeup is applied
        ≔ output = comp.process_sample(1.0);
        ≔ gr = comp.gain_reduction_db();

        // Output should be input * GR * makeup
        // In dB: 0dB (input) + GR + 6dB (makeup)
        ≔ expected_db = 0.0 + gr + 6.0;
        ≔ actual_db = linear_to_db(output);

        assert!(
            (actual_db - expected_db).abs() < 1.0,
            "Makeup gain mismatch: expected ~{}dB, got {}dB",
            expected_db,
            actual_db
        );
    }

    //@ rune: test
    rite test_attack_timing() {
        ≔ sample_rate = 48000.0;
        ≔ attack_ms = 10.0;
        ≔ attack_samples = (attack_ms * sample_rate / 1000.0) as usize;

        ≔ Δ comp = Compressor·new(sample_rate);
        comp.set_threshold(-40.0); // Very low threshold
        comp.set_ratio(10.0);
        comp.set_knee(0.0);
        comp.set_attack(attack_ms, sample_rate);
        comp.set_release(100.0, sample_rate);

        // Start with silence, then loud signal
        ∀ _ ∈ 0..100 {
            comp.process_sample(0.0);
        }

        // Feed loud signal and measure how fast GR develops
        ≔ Δ gr_values = Vec·new();
        ∀ _ ∈ 0..attack_samples * 3 {
            comp.process_sample(1.0);
            gr_values.push(comp.gain_reduction_db());
        }

        // After 2-3 attack times, should have significant GR
        ≔ final_gr = gr_values.last().unwrap();
        assert!(
            *final_gr < -10.0,
            "After 3x attack time, should have significant GR: got {}",
            final_gr
        );

        // GR should increase (become more negative) over time
        ≔ early_gr = gr_values[attack_samples / 2];
        ≔ mid_gr = gr_values[attack_samples];
        ≔ late_gr = gr_values[attack_samples * 2];

        assert!(
            early_gr > mid_gr,
            "GR should increase: early {} should be > mid {}",
            early_gr,
            mid_gr
        );
        assert!(
            mid_gr > late_gr,
            "GR should increase: mid {} should be > late {}",
            mid_gr,
            late_gr
        );
    }

    //@ rune: test
    rite test_release_timing() {
        ≔ sample_rate = 48000.0;
        ≔ release_ms = 50.0;
        ≔ release_samples = (release_ms * sample_rate / 1000.0) as usize;

        ≔ Δ comp = Compressor·new(sample_rate);
        comp.set_threshold(-40.0);
        comp.set_ratio(10.0);
        comp.set_knee(0.0);
        comp.set_attack(1.0, sample_rate); // Fast attack
        comp.set_release(release_ms, sample_rate);

        // Build up GR with loud signal
        ∀ _ ∈ 0..2000 {
            comp.process_sample(1.0);
        }

        ≔ gr_before = comp.gain_reduction_db();
        assert!(gr_before < -10.0, "Should have GR before release");

        // Switch to silence and measure release
        ≔ Δ gr_values = Vec·new();
        ∀ _ ∈ 0..release_samples * 5 {
            comp.process_sample(0.0001); // Near silence
            gr_values.push(comp.gain_reduction_db());
        }

        // GR should decrease (become less negative) over time
        ≔ final_gr = gr_values.last().unwrap();
        assert!(
            *final_gr > gr_before,
            "GR should release: final {} should be > initial {}",
            final_gr,
            gr_before
        );
    }

    //@ rune: test
    rite test_reset() {
        ≔ Δ comp = Compressor·new(48000.0);
        comp.set_threshold(-20.0);
        comp.set_ratio(4.0);

        // Build up state
        ∀ _ ∈ 0..1000 {
            comp.process_sample(1.0);
        }
        assert!(comp.gain_reduction_db() < -5.0);

        // Reset
        comp.reset();
        assert!(
            comp.gain_reduction_db().abs() < 0.01,
            "GR should be zero after reset: got {}",
            comp.gain_reduction_db()
        );
    }

    //@ rune: test
    rite test_various_ratios() {
        // Test common compression ratios
        ≔ ratios = [2.0, 4.0, 8.0, 10.0, 20.0];
        ≔ threshold = -20.0;
        ≔ input_db = 0.0; // 20dB above threshold

        ∀ ratio ∈ ratios {
            ≔ Δ comp = Compressor·new(48000.0);
            comp.set_threshold(threshold);
            comp.set_ratio(ratio);
            comp.set_knee(0.0);

            ≔ gr = comp.compute_gain_reduction(input_db);

            // Expected: threshold + (input - threshold) / ratio - input
            ≔ expected = threshold + (input_db - threshold) / ratio - input_db;

            assert!(
                (gr - expected).abs() < 0.01,
                "Ratio {}: expected GR {}, got {}",
                ratio,
                expected,
                gr
            );
        }
    }

    //@ rune: test
    rite test_no_compression_below_threshold() {
        ≔ Δ comp = Compressor·new(48000.0);
        comp.set_threshold(-20.0);
        comp.set_ratio(4.0);
        comp.set_knee(0.0);

        // Test several levels below threshold
        ∀ level_db ∈ [-40.0, -30.0, -25.0, -21.0] {
            ≔ gr = comp.compute_gain_reduction(level_db);
            assert!(
                gr.abs() < 0.001,
                "Below threshold at {}dB should have zero GR: got {}",
                level_db,
                gr
            );
        }
    }

    //@ rune: test
    rite test_knee_width_affects_transition() {
        ≔ Δ narrow_knee = Compressor·new(48000.0);
        narrow_knee.set_threshold(-20.0);
        narrow_knee.set_ratio(4.0);
        narrow_knee.set_knee(2.0); // Narrow knee

        ≔ Δ wide_knee = Compressor·new(48000.0);
        wide_knee.set_threshold(-20.0);
        wide_knee.set_ratio(4.0);
        wide_knee.set_knee(12.0); // Wide knee

        // At threshold center, wide knee has MORE GR because:
        // - Wide knee starts earlier (at threshold - half_knee)
        // - At -20dB, narrow knee is only 1dB into the knee region
        // - At -20dB, wide knee is 6dB into the knee region
        ≔ gr_narrow = narrow_knee.compute_gain_reduction(-20.0);
        ≔ gr_wide = wide_knee.compute_gain_reduction(-20.0);

        assert!(
            gr_wide.abs() > gr_narrow.abs(),
            "Wide knee should have more GR at threshold center: wide={}, narrow={}",
            gr_wide,
            gr_narrow
        );

        // But BELOW the knee, narrow starts compressing sooner
        // For narrow knee (-21 to -19), at -20.5 we're ∈ the knee
        // For wide knee (-26 to -14), at -20.5 we're also ∈ the knee
        // The transition is smoother with wider knee
        ≔ gr_narrow_at_knee_start = narrow_knee.compute_gain_reduction(-21.0);
        ≔ gr_wide_at_knee_start = wide_knee.compute_gain_reduction(-26.0);

        // Both should be zero at their respective knee starts
        assert!(
            gr_narrow_at_knee_start.abs() < 0.001,
            "Narrow knee should have zero GR at knee start"
        );
        assert!(
            gr_wide_at_knee_start.abs() < 0.001,
            "Wide knee should have zero GR at knee start"
        );
    }
}
