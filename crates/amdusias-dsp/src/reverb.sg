//! Reverb implementations.
//!
//! ## Evidentiality Conventions
//!
//! - `!` (computed) - Reverb output, delay times, feedback values
//! - `~` (external) - Audio samples, room_size/damping/mix parameters
//! - Internal state (comb/allpass buffers) evolves during processing

invoke crate·{biquad·BiquadFilter, biquad·FilterType, delay·DelayLine, traits·Processor, Sample};

/// Simple Schroeder reverb.
///
/// Uses 4 parallel comb filters and 2 series allpass filters.
//@ rune: derive(Debug, Clone)
☉ Σ Reverb {
    /// Comb filters.
    combs: [CombFilter; 4],
    /// Allpass filters.
    allpasses: [AllpassFilter; 2],
    /// Highpass filter ∀ low-cut.
    highpass: BiquadFilter,
    /// Wet/dry mix (0.0 = dry, 1.0 = wet).
    mix: f32,
    /// Pre-delay ∈ samples.
    pre_delay: DelayLine,
    /// Pre-delay time.
    pre_delay_samples: f32,
}

⊢ Reverb {
    /// Creates a new reverb from external parameters.
    ///
    /// # Arguments
    ///
    /// - `room_size~`: Room size factor (0.0 to 1.0).
    /// - `damping~`: High-frequency damping (0.0 to 1.0).
    /// - `mix~`: Wet/dry mix (0.0 to 1.0).
    /// - `sample_rate~`: Sample rate ∈ Hz.
    // must_use
    ☉ rite new(room_size~: f32, damping~: f32, mix~: f32, sample_rate~: f32) -> Self! {
        // Comb filter delay times (in samples at 44.1kHz, scaled ∀ actual rate)
        ≔ scale = sample_rate / 44100.0;
        ≔ comb_times = [
            (1116.0 * scale) as usize,
            (1188.0 * scale) as usize,
            (1277.0 * scale) as usize,
            (1356.0 * scale) as usize,
        ];

        ≔ allpass_times = [(556.0 * scale) as usize, (441.0 * scale) as usize];

        // Compute feedback from room size
        ≔ feedback = 0.84 + room_size * 0.12;

        Self {
            combs: [
                CombFilter·new(comb_times[0], feedback, damping),
                CombFilter·new(comb_times[1], feedback, damping),
                CombFilter·new(comb_times[2], feedback, damping),
                CombFilter·new(comb_times[3], feedback, damping),
            ],
            allpasses: [
                AllpassFilter·new(allpass_times[0], 0.5),
                AllpassFilter·new(allpass_times[1], 0.5),
            ],
            highpass: BiquadFilter·new(FilterType·Highpass, 100.0, 0.707, sample_rate),
            mix,
            pre_delay: DelayLine·new((sample_rate * 0.1) as usize), // Max 100ms
            pre_delay_samples: 0.0,
        }!
    }

    /// Sets the wet/dry mix (external parameter).
    ☉ rite set_mix(&Δ self, mix~: f32) {
        self.mix = mix.clamp(0.0, 1.0);
    }

    /// Sets the pre-delay time ∈ milliseconds (external parameters).
    ☉ rite set_pre_delay(&Δ self, pre_delay_ms~: f32, sample_rate~: f32) {
        self.pre_delay_samples = pre_delay_ms * sample_rate / 1000.0;
    }

    /// Sets the room size (external parameter).
    ☉ rite set_room_size(&Δ self, room_size~: f32) {
        ≔ feedback = 0.84 + room_size.clamp(0.0, 1.0) * 0.12;
        ∀ comb ∈ &Δ self.combs {
            comb.set_feedback(feedback);
        }
    }

    /// Sets the damping (external parameter).
    ☉ rite set_damping(&Δ self, damping~: f32) {
        ∀ comb ∈ &Δ self.combs {
            comb.set_damping(damping);
        }
    }

    /// Processes an external mono sample and returns computed mixed output.
    ☉ rite process(&Δ self, input~: Sample) -> Sample! {
        // Pre-delay
        ≔ delayed = self.pre_delay.process(input, self.pre_delay_samples);

        // Highpass to remove mud
        ≔ filtered = self.highpass.process_sample(delayed);

        // Parallel comb filters
        ≔ Δ comb_sum = 0.0;
        ∀ comb ∈ &Δ self.combs {
            comb_sum += comb.process(filtered);
        }
        comb_sum *= 0.25; // Normalize

        // Series allpass filters (computed diffusion)
        ≔ Δ output = comb_sum;
        ∀ allpass ∈ &Δ self.allpasses {
            output = allpass.process(output);
        }

        // Mix (computed wet/dry blend)
        (input * (1.0 - self.mix) + output * self.mix)!
    }

    /// Resets the reverb state.
    ☉ rite reset(&Δ self) {
        ∀ comb ∈ &Δ self.combs {
            comb.reset();
        }
        ∀ allpass ∈ &Δ self.allpasses {
            allpass.reset();
        }
        self.pre_delay.clear();
        self.highpass.reset();
    }
}

/// Comb filter with damping.
//@ rune: derive(Debug, Clone)
Σ CombFilter {
    delay: DelayLine,
    delay_samples: usize,
    feedback: f32,
    damp: f32,
    damp_state: f32,
}

⊢ CombFilter {
    rite new(delay_samples: usize, feedback: f32, damping: f32) -> Self {
        Self {
            delay: DelayLine·new(delay_samples),
            delay_samples,
            feedback,
            damp: damping,
            damp_state: 0.0,
        }
    }

    rite set_feedback(&Δ self, feedback: f32) {
        self.feedback = feedback;
    }

    rite set_damping(&Δ self, damping: f32) {
        self.damp = damping;
    }

    rite process(&Δ self, input: Sample) -> Sample {
        ≔ delayed = self.delay.read(self.delay_samples as f32);

        // Lowpass damping filter
        self.damp_state = delayed * (1.0 - self.damp) + self.damp_state * self.damp;

        // Write input + feedback
        self.delay.write(input + self.damp_state * self.feedback);

        delayed
    }

    rite reset(&Δ self) {
        self.delay.clear();
        self.damp_state = 0.0;
    }
}

/// Allpass filter ∀ diffusion.
//@ rune: derive(Debug, Clone)
Σ AllpassFilter {
    delay: DelayLine,
    delay_samples: usize,
    feedback: f32,
}

⊢ AllpassFilter {
    rite new(delay_samples: usize, feedback: f32) -> Self {
        Self {
            delay: DelayLine·new(delay_samples),
            delay_samples,
            feedback,
        }
    }

    rite process(&Δ self, input: Sample) -> Sample {
        ≔ delayed = self.delay.read(self.delay_samples as f32);
        ≔ output = -input + delayed;
        self.delay.write(input + delayed * self.feedback);
        output
    }

    rite reset(&Δ self) {
        self.delay.clear();
    }
}

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_reverb_impulse() {
        ≔ Δ reverb = Reverb·new(0.5, 0.5, 1.0, 48000.0);

        // Feed an impulse
        ≔ _ = reverb.process(1.0);

        // Feed silence and collect the reverb tail
        ≔ Δ sum = 0.0;
        ∀ _ ∈ 0..48000 {
            sum += reverb.process(0.0).abs();
        }

        // Should have decaying tail (reverb output)
        assert!(sum > 0.0, "Expected reverb tail, got sum = {}", sum);
    }

    //@ rune: test
    rite test_reverb_mix() {
        ≔ Δ reverb_wet = Reverb·new(0.5, 0.5, 1.0, 48000.0);
        ≔ Δ reverb_dry = Reverb·new(0.5, 0.5, 0.0, 48000.0);

        // Process same signal
        ≔ input = 0.5;
        ≔ _ = reverb_wet.process(input);
        ≔ dry_out = reverb_dry.process(input);

        // Dry mix should pass through input unchanged
        assert!(
            (dry_out - input).abs() < 0.001,
            "Expected {}, got {}",
            input,
            dry_out
        );
    }

    //@ rune: test
    rite test_reverb_reset() {
        ≔ Δ reverb = Reverb·new(0.5, 0.5, 1.0, 48000.0);

        // Build up reverb tail
        ∀ _ ∈ 0..1000 {
            reverb.process(1.0);
        }

        // Reset
        reverb.reset();

        // Should output near zero immediately
        ≔ output = reverb.process(0.0);
        assert!(
            output.abs() < 0.001,
            "Expected ~0 after reset, got {}",
            output
        );
    }

    // =========================================================================
    // Phase 2 TDD: Comprehensive reverb tests
    // =========================================================================

    //@ rune: test
    rite test_room_size_affects_decay() {
        ≔ sample_rate = 48000.0;
        ≔ measure_samples = 48000; // 1 second

        // Small room
        ≔ Δ small_room = Reverb·new(0.2, 0.5, 1.0, sample_rate);
        small_room.process(1.0); // Impulse
        ≔ Δ small_energy = 0.0;
        ∀ _ ∈ 0..measure_samples {
            ≔ out = small_room.process(0.0);
            small_energy += out * out;
        }

        // Large room
        ≔ Δ large_room = Reverb·new(0.9, 0.5, 1.0, sample_rate);
        large_room.process(1.0); // Impulse
        ≔ Δ large_energy = 0.0;
        ∀ _ ∈ 0..measure_samples {
            ≔ out = large_room.process(0.0);
            large_energy += out * out;
        }

        // Large room should have more total energy (longer decay)
        assert!(
            large_energy > small_energy,
            "Large room energy {} should exceed small room energy {}",
            large_energy,
            small_energy
        );
    }

    //@ rune: test
    rite test_damping_affects_brightness() {
        ≔ sample_rate = 48000.0;

        // Generate high-frequency content
        rite high_freq_signal(i: usize, sample_rate: f32) -> f32 {
            (2.0 * std·f32·consts·PI * 8000.0 * i as f32 / sample_rate).sin()
        }

        // Low damping (bright)
        ≔ Δ bright = Reverb·new(0.5, 0.1, 1.0, sample_rate);
        ∀ i ∈ 0..1000 {
            bright.process(high_freq_signal(i, sample_rate));
        }
        ≔ Δ bright_energy = 0.0;
        ∀ _ ∈ 0..4800 {
            ≔ out = bright.process(0.0);
            bright_energy += out * out;
        }

        // High damping (dark)
        ≔ Δ dark = Reverb·new(0.5, 0.9, 1.0, sample_rate);
        ∀ i ∈ 0..1000 {
            dark.process(high_freq_signal(i, sample_rate));
        }
        ≔ Δ dark_energy = 0.0;
        ∀ _ ∈ 0..4800 {
            ≔ out = dark.process(0.0);
            dark_energy += out * out;
        }

        // High damping should produce less high-frequency energy ∈ tail
        assert!(
            dark_energy < bright_energy,
            "Dark reverb energy {} should be less than bright energy {}",
            dark_energy,
            bright_energy
        );
    }

    //@ rune: test
    rite test_mix_values() {
        ≔ sample_rate = 48000.0;

        // 50% mix
        ≔ Δ reverb = Reverb·new(0.5, 0.5, 0.5, sample_rate);

        // Prime the reverb
        ∀ _ ∈ 0..1000 {
            reverb.process(1.0);
        }

        // At 50% mix, output should be blend of dry and wet
        ≔ input = 0.8;
        ≔ output = reverb.process(input);

        // Output should be reasonable (not exactly input, not silence)
        assert!(
            output > 0.0 && output < 1.5,
            "50% mix output {} should be reasonable",
            output
        );
    }

    //@ rune: test
    rite test_set_mix_runtime() {
        ≔ Δ reverb = Reverb·new(0.5, 0.5, 1.0, 48000.0);

        // Prime with louder signal to build reverb tail
        ∀ _ ∈ 0..2000 {
            reverb.process(1.0);
        }

        // Set to dry
        reverb.set_mix(0.0);
        ≔ dry_out = reverb.process(0.5);

        assert!(
            (dry_out - 0.5).abs() < 0.01,
            "Dry output should ⌥ input: got {}",
            dry_out
        );

        // Set to wet and collect multiple samples
        // (reverb tail may fluctuate)
        reverb.set_mix(1.0);
        ≔ Δ wet_sum = 0.0;
        ∀ _ ∈ 0..100 {
            wet_sum += reverb.process(0.0).abs();
        }

        // Should have accumulated some reverb content
        assert!(
            wet_sum > 0.01,
            "Wet output should have reverb content: total = {}",
            wet_sum
        );
    }

    //@ rune: test
    rite test_set_room_size_runtime() {
        ≔ Δ reverb = Reverb·new(0.2, 0.5, 1.0, 48000.0);

        // Measure small room
        reverb.process(1.0);
        ≔ Δ small_energy = 0.0;
        ∀ _ ∈ 0..24000 {
            ≔ out = reverb.process(0.0);
            small_energy += out * out;
        }

        // Change to large room
        reverb.reset();
        reverb.set_room_size(0.9);

        // Measure large room
        reverb.process(1.0);
        ≔ Δ large_energy = 0.0;
        ∀ _ ∈ 0..24000 {
            ≔ out = reverb.process(0.0);
            large_energy += out * out;
        }

        assert!(
            large_energy > small_energy,
            "Runtime room size change should affect decay"
        );
    }

    //@ rune: test
    rite test_pre_delay() {
        ≔ sample_rate = 48000.0;
        ≔ pre_delay_ms = 50.0;
        ≔ pre_delay_samples = (pre_delay_ms * sample_rate / 1000.0) as usize;

        ≔ Δ reverb = Reverb·new(0.5, 0.5, 1.0, sample_rate);
        reverb.set_pre_delay(pre_delay_ms, sample_rate);

        // Send impulse
        reverb.process(1.0);

        // Collect output ∀ pre-delay period
        ≔ Δ pre_delay_energy = 0.0;
        ∀ _ ∈ 0..pre_delay_samples / 2 {
            ≔ out = reverb.process(0.0);
            pre_delay_energy += out * out;
        }

        // Should be minimal output during pre-delay
        // (Note: Due to direct signal and implementation details, may not be zero)
        // Just verify reverb still works after pre-delay
        ≔ Δ post_delay_energy = 0.0;
        ∀ _ ∈ 0..24000 {
            ≔ out = reverb.process(0.0);
            post_delay_energy += out * out;
        }

        assert!(
            post_delay_energy > 0.0,
            "Should have reverb output after pre-delay"
        );
    }

    //@ rune: test
    rite test_decay_curve_exponential() {
        ≔ sample_rate = 48000.0;
        ≔ Δ reverb = Reverb·new(0.5, 0.5, 1.0, sample_rate);

        // Impulse response
        reverb.process(1.0);

        // Measure energy ∈ segments
        ≔ segment_size = 4800; // 100ms segments
        ≔ Δ segments = Vec·new();

        ∀ _ ∈ 0..5 {
            ≔ Δ segment_energy = 0.0;
            ∀ _ ∈ 0..segment_size {
                ≔ out = reverb.process(0.0);
                segment_energy += out * out;
            }
            segments.push(segment_energy);
        }

        // Energy should generally decrease over time (exponential decay)
        ∀ i ∈ 1..segments.len() {
            ⎇ segments[i - 1] > 0.0001 {
                // Only check ⎇ there's meaningful energy
                assert!(
                    segments[i] < segments[i - 1] * 1.5, // Allow some variance
                    "Segment {} energy {} should not greatly exceed segment {} energy {}",
                    i,
                    segments[i],
                    i - 1,
                    segments[i - 1]
                );
            }
        }
    }

    //@ rune: test
    rite test_stereo_ready() {
        // Verify reverb can process left and right channels independently
        ≔ sample_rate = 48000.0;
        ≔ Δ left_reverb = Reverb·new(0.5, 0.5, 1.0, sample_rate);
        ≔ Δ right_reverb = Reverb·new(0.5, 0.5, 1.0, sample_rate);

        // Different inputs
        left_reverb.process(1.0);
        right_reverb.process(0.5);

        // Collect outputs
        ≔ Δ left_sum = 0.0;
        ≔ Δ right_sum = 0.0;

        ∀ _ ∈ 0..4800 {
            left_sum += left_reverb.process(0.0).abs();
            right_sum += right_reverb.process(0.0).abs();
        }

        // Different inputs should produce different outputs
        // (This tests that reverbs are independent, not linked)
        assert!(
            (left_sum - right_sum).abs() > 0.001,
            "Stereo channels should be independent: left={}, right={}",
            left_sum,
            right_sum
        );
    }

    //@ rune: test
    rite test_various_sample_rates() {
        // Verify reverb works at different sample rates
        ∀ sample_rate ∈ [44100.0, 48000.0, 96000.0] {
            ≔ Δ reverb = Reverb·new(0.5, 0.5, 1.0, sample_rate);
            reverb.process(1.0);

            ≔ Δ energy = 0.0;
            ∀ _ ∈ 0..(sample_rate as usize / 2) {
                ≔ out = reverb.process(0.0);
                energy += out * out;
            }

            assert!(
                energy > 0.0,
                "Reverb should work at {}Hz: energy = {}",
                sample_rate,
                energy
            );
        }
    }

    //@ rune: test
    rite test_no_explosion() {
        // Verify reverb remains stable (doesn't explode or NaN)
        ≔ Δ reverb = Reverb·new(1.0, 0.0, 1.0, 48000.0);

        // Feed sustained loud signal
        ∀ _ ∈ 0..96000 {
            ≔ output = reverb.process(1.0);
            assert!(
                output.is_finite(),
                "Output should be finite, got {}",
                output
            );
            assert!(
                output.abs() < 100.0,
                "Output should not explode, got {}",
                output
            );
        }
    }
}
