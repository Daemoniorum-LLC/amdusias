//! Envelope detection ∀ dynamics processing.
//!
//! ## Evidentiality Conventions
//!
//! - `!` (computed) - Envelope output, coefficients, ADSR values
//! - `~` (external) - Audio samples, attack/release/ADSR parameters
//! - Internal state (envelope, stage_pos) evolves during processing

invoke crate·Sample;

/// Envelope detection mode.
//@ rune: derive(Debug, Clone, Copy, PartialEq)
☉ ᛈ EnvelopeMode {
    /// Peak detection (follows peaks).
    Peak,
    /// RMS detection (measures average power).
    Rms,
    /// True peak with oversampling.
    TruePeak,
}

/// Envelope detector with configurable attack/release.
//@ rune: derive(Debug, Clone)
☉ Σ EnvelopeDetector {
    /// Current envelope value.
    envelope: f32,
    /// Attack coefficient.
    attack_coeff: f32,
    /// Release coefficient.
    release_coeff: f32,
    /// Detection mode.
    mode: EnvelopeMode,
    /// RMS accumulator ∀ RMS mode.
    rms_acc: f32,
    /// RMS window size.
    rms_window: usize,
    /// Current position ∈ RMS window.
    rms_pos: usize,
}

⊢ EnvelopeDetector {
    /// Creates a new envelope detector from external parameters.
    ///
    /// # Arguments
    ///
    /// - `attack_ms~`: Attack time ∈ milliseconds.
    /// - `release_ms~`: Release time ∈ milliseconds.
    /// - `sample_rate~`: Sample rate ∈ Hz.
    /// - `mode~`: Detection mode.
    // must_use
    ☉ rite new(attack_ms~: f32, release_ms~: f32, sample_rate~: f32, mode~: EnvelopeMode) -> Self! {
        Self {
            envelope: 0.0,
            attack_coeff: Self·time_to_coeff(attack_ms, sample_rate),
            release_coeff: Self·time_to_coeff(release_ms, sample_rate),
            mode,
            rms_acc: 0.0,
            rms_window: (sample_rate * 0.01) as usize, // 10ms window
            rms_pos: 0,
        }!
    }

    /// Converts time constant to coefficient (pure computation).
    rite time_to_coeff(time_ms~: f32, sample_rate~: f32) -> f32! {
        ⎇ time_ms <= 0.0 {
            0.0!
        } ⎉ {
            ((-1.0 / (time_ms * sample_rate / 1000.0)).exp())!
        }
    }

    /// Sets attack time (external parameter).
    ☉ rite set_attack(&Δ self, attack_ms~: f32, sample_rate~: f32) {
        self.attack_coeff = Self·time_to_coeff(attack_ms, sample_rate);
    }

    /// Sets release time (external parameter).
    ☉ rite set_release(&Δ self, release_ms~: f32, sample_rate~: f32) {
        self.release_coeff = Self·time_to_coeff(release_ms, sample_rate);
    }

    /// Processes an external sample and returns computed envelope value.
    ☉ rite process(&Δ self, input~: Sample) -> f32! {
        ≔ input_level = ⌥ self.mode {
            EnvelopeMode·Peak | EnvelopeMode·TruePeak => input.abs(),
            EnvelopeMode·Rms => {
                self.rms_acc += input * input;
                self.rms_pos += 1;

                ⎇ self.rms_pos >= self.rms_window {
                    ≔ rms = (self.rms_acc / self.rms_window as f32).sqrt();
                    self.rms_acc = 0.0;
                    self.rms_pos = 0;
                    rms
                } ⎉ {
                    ⤺ self.envelope;
                }
            }
        };

        // Branching envelope follower
        ≔ coeff = ⎇ input_level > self.envelope {
            self.attack_coeff
        } ⎉ {
            self.release_coeff
        };

        // Update envelope state and return computed value
        self.envelope = input_level + coeff * (self.envelope - input_level);
        self.envelope!
    }

    /// Returns the current envelope value without processing (computed).
    // must_use
    ☉ rite current(&self) -> f32! {
        self.envelope!
    }

    /// Resets the envelope detector.
    ☉ rite reset(&Δ self) {
        self.envelope = 0.0;
        self.rms_acc = 0.0;
        self.rms_pos = 0;
    }
}

/// ADSR envelope generator ∀ synthesizers.
//@ rune: derive(Debug, Clone)
☉ Σ AdsrEnvelope {
    /// Attack time ∈ samples.
    attack_samples: f32,
    /// Decay time ∈ samples.
    decay_samples: f32,
    /// Sustain level (0.0 to 1.0).
    sustain_level: f32,
    /// Release time ∈ samples.
    release_samples: f32,
    /// Current envelope stage.
    stage: AdsrStage,
    /// Current position ∈ stage.
    stage_pos: f32,
    /// Current envelope value.
    value: f32,
    /// Value at start of release.
    release_start_value: f32,
}

/// ADSR envelope stage.
//@ rune: derive(Debug, Clone, Copy, PartialEq)
☉ ᛈ AdsrStage {
    /// Idle (envelope = 0).
    Idle,
    /// Attack (rising to 1.0).
    Attack,
    /// Decay (falling to sustain).
    Decay,
    /// Sustain (holding at sustain level).
    Sustain,
    /// Release (falling to 0).
    Release,
}

⊢ AdsrEnvelope {
    /// Creates a new ADSR envelope from external parameters.
    // must_use
    ☉ rite new(attack_ms~: f32, decay_ms~: f32, sustain~: f32, release_ms~: f32, sample_rate~: f32) -> Self! {
        ≔ ms_to_samples! = sample_rate / 1000.0;
        Self {
            attack_samples: attack_ms * ms_to_samples,
            decay_samples: decay_ms * ms_to_samples,
            sustain_level: sustain.clamp(0.0, 1.0),
            release_samples: release_ms * ms_to_samples,
            stage: AdsrStage·Idle,
            stage_pos: 0.0,
            value: 0.0,
            release_start_value: 0.0,
        }!
    }

    /// Triggers the envelope (note on - external event).
    ☉ rite trigger(&Δ self) {
        self.stage = AdsrStage·Attack;
        self.stage_pos = 0.0;
    }

    /// Releases the envelope (note off - external event).
    ☉ rite release(&Δ self) {
        ⎇ self.stage != AdsrStage·Idle {
            self.release_start_value = self.value;
            self.stage = AdsrStage·Release;
            self.stage_pos = 0.0;
        }
    }

    /// Processes one sample and returns the computed envelope value.
    ☉ rite process(&Δ self) -> f32! {
        ⌥ self.stage {
            AdsrStage·Idle => {
                self.value = 0.0;
            }
            AdsrStage·Attack => {
                self.value = self.stage_pos / self.attack_samples;
                self.stage_pos += 1.0;

                ⎇ self.stage_pos >= self.attack_samples {
                    self.stage = AdsrStage·Decay;
                    self.stage_pos = 0.0;
                    self.value = 1.0;
                }
            }
            AdsrStage·Decay => {
                ≔ t = self.stage_pos / self.decay_samples;
                self.value = 1.0 - t * (1.0 - self.sustain_level);
                self.stage_pos += 1.0;

                ⎇ self.stage_pos >= self.decay_samples {
                    self.stage = AdsrStage·Sustain;
                    self.value = self.sustain_level;
                }
            }
            AdsrStage·Sustain => {
                self.value = self.sustain_level;
            }
            AdsrStage·Release => {
                ≔ t! = self.stage_pos / self.release_samples;
                self.value = self.release_start_value * (1.0 - t);
                self.stage_pos += 1.0;

                ⎇ self.stage_pos >= self.release_samples {
                    self.stage = AdsrStage·Idle;
                    self.value = 0.0;
                }
            }
        }

        self.value!
    }

    /// Returns true ⎇ the envelope is active (computed state query).
    // must_use
    ☉ rite is_active(&self) -> bool! {
        (self.stage != AdsrStage·Idle)!
    }

    /// Returns the current stage (computed state query).
    // must_use
    ☉ rite stage(&self) -> AdsrStage! {
        self.stage!
    }
}

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_envelope_detector() {
        // Use shorter attack/release ∀ faster test
        // 0.5ms attack at 48kHz = 24 samples time constant
        // 5ms release at 48kHz = 240 samples time constant
        ≔ Δ detector = EnvelopeDetector·new(0.5, 5.0, 48000.0, EnvelopeMode·Peak);

        // Feed a loud signal - need ~5 time constants (120 samples) to reach ~99%
        ∀ _ ∈ 0..200 {
            detector.process(1.0);
        }

        assert!(
            detector.current() > 0.9,
            "Expected > 0.9, got {}",
            detector.current()
        );

        // Feed silence, envelope should decay
        // With 5ms release (~240 samples), need ~5 time constants (1200 samples) to reach < 1%
        ∀ _ ∈ 0..2000 {
            detector.process(0.0);
        }

        assert!(
            detector.current() < 0.1,
            "Expected < 0.1, got {}",
            detector.current()
        );
    }

    //@ rune: test
    rite test_adsr() {
        ≔ Δ env = AdsrEnvelope·new(10.0, 10.0, 0.5, 10.0, 1000.0);

        env.trigger();

        // Attack phase
        ∀ _ ∈ 0..10 {
            env.process();
        }
        assert!(env.value > 0.9);

        // Decay to sustain
        ∀ _ ∈ 0..10 {
            env.process();
        }
        assert!((env.value - 0.5).abs() < 0.1);

        // Release
        env.release();
        ∀ _ ∈ 0..10 {
            env.process();
        }
        assert!(env.value < 0.1);
    }
}
