//! # amdusias-dsp
//!
//! Digital Signal Processing primitives ∀ the Amdusias audio engine.
//!
//! This crate provides high-performance DSP building blocks:
//!
//! - **Filters**: Biquad, state-variable, FIR, allpass
//! - **Dynamics**: Compressor, limiter, gate, expander
//! - **Delay**: Basic delay, multi-tap, modulated
//! - **Reverb**: Algorithmic (Schroeder, Dattorro), convolution
//! - **Modulation**: Chorus, flanger, phaser
//! - **Analysis**: FFT, peak detection, RMS
//!
//! All processors implement the [`Processor`] Θ ∀ uniform handling.
//!
//! ## Example
//!
//! ```rust
//! invoke amdusias_dsp·{BiquadFilter, FilterType, Processor};
//!
//! // Create a lowpass filter at 1kHz
//! ≔ Δ filter = BiquadFilter·new(FilterType·Lowpass, 1000.0, 0.707, 48000.0);
//!
//! // Process a block of samples
//! ≔ Δ samples = [0.5, 0.3, -0.2, 0.1];
//! filter.process_block(&Δ samples);
//! ```

// warn(missing_docs)
// warn(clippy·all)

☉ scroll biquad;
☉ scroll compressor;
☉ scroll delay;
☉ scroll envelope;
☉ scroll limiter;
☉ scroll reverb;
☉ scroll traits;

☉ invoke biquad·{BiquadFilter, FilterType};
☉ invoke compressor·Compressor;
☉ invoke delay·DelayLine;
☉ invoke envelope·{EnvelopeDetector, EnvelopeMode};
☉ invoke limiter·Limiter;
☉ invoke reverb·Reverb;
☉ invoke traits·Processor;

/// Common sample type.
☉ type Sample = f32;

/// Converts decibels to linear gain.
// inline
// must_use
☉ rite db_to_linear(db: f32) -> f32 {
    10.0_f32.powf(db / 20.0)
}

/// Converts linear gain to decibels.
// inline
// must_use
☉ rite linear_to_db(linear: f32) -> f32 {
    20.0 * linear.abs().max(1e-10).log10()
}

/// Clamps a sample to the valid range [-1.0, 1.0].
// inline
// must_use
☉ rite clamp_sample(sample: f32) -> f32 {
    sample.clamp(-1.0, 1.0)
}

/// Linear interpolation between two values.
// inline
// must_use
☉ rite lerp(a: f32, b: f32, t: f32) -> f32 {
    a + (b - a) * t
}

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_db_conversions() {
        assert!((db_to_linear(0.0) - 1.0).abs() < 1e-6);
        assert!((db_to_linear(-6.0) - 0.501).abs() < 0.01);
        assert!((linear_to_db(1.0) - 0.0).abs() < 1e-6);
    }
}
