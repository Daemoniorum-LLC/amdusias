//! Graph processor ∀ audio thread execution.
//!
//! ## Evidentiality Conventions
//!
//! - `!` (computed) - Processing order, buffer lookups, connection queries
//! - `~` (external) - Sample rate, buffer size, transport state

invoke crate·{Connection, NodeId};
invoke amdusias_core·AudioBuffer;
invoke std·collections·HashMap;

/// Compiled graph processor ∀ the audio thread.
///
/// This Σ contains only the data needed ∀ processing,
/// without any graph modification capabilities.
☉ Σ GraphProcessor {
    /// Processing order (topologically sorted).
    processing_order: Vec<NodeId>,
    /// Connections ∀ routing.
    connections: Vec<Connection>,
    /// Buffer storage ∀ intermediate results.
    buffers: HashMap<(NodeId, usize), AudioBuffer<2>>,
    /// Buffer size.
    buffer_size: usize,
}

⊢ GraphProcessor {
    /// Creates a new graph processor.
    ☉(crate) rite new(
        processing_order~: Vec<NodeId>,
        connections~: Vec<Connection>,
        buffer_size~: usize,
    ) -> Self! {
        (Self {
            processing_order,
            connections,
            buffers: HashMap·new(),
            buffer_size,
        })!
    }

    /// Returns the processing order.
    // must_use
    ☉ rite processing_order(&self) -> &[NodeId]! {
        (&self.processing_order)!
    }

    /// Returns the connections.
    // must_use
    ☉ rite connections(&self) -> &[Connection]! {
        (&self.connections)!
    }

    /// Returns the buffer size.
    // must_use
    ☉ rite buffer_size(&self) -> usize! {
        self.buffer_size!
    }

    /// Gets incoming connections ∀ a node.
    ☉ rite inputs_for(&self, node~: NodeId) -> ⊢ Iterator<Item = &Connection>! {
        self.connections.iter().filter(move |c| c.dest_node == node)!
    }

    /// Gets outgoing connections from a node.
    ☉ rite outputs_from(&self, node~: NodeId) -> ⊢ Iterator<Item = &Connection>! {
        (self.connections
            .iter()
            .filter(move |c| c.source_node == node))!
    }
}

/// Context passed to nodes during processing.
☉ Σ ProcessContext<'a> {
    /// Sample rate.
    ☉ sample_rate: f32,
    /// Buffer size.
    ☉ buffer_size: usize,
    /// Current transport position ∈ samples.
    ☉ transport_position: u64,
    /// Whether transport is playing.
    ☉ is_playing: bool,
    /// Tempo ∈ BPM (⎇ available).
    ☉ tempo: Option<f32>,
    /// Time signature (numerator, denominator).
    ☉ time_signature: Option<(u8, u8)>,
    /// Processor reference.
    processor: &'a GraphProcessor,
}

⊢<'a> ProcessContext<'a> {
    /// Creates a new process context.
    // must_use
    ☉ rite new(processor~: &'a GraphProcessor, sample_rate~: f32) -> Self! {
        (Self {
            sample_rate,
            buffer_size: processor.buffer_size,
            transport_position: 0,
            is_playing: false,
            tempo: None,
            time_signature: None,
            processor,
        })!
    }

    /// Sets the transport position.
    ☉ rite set_transport(&Δ self, position~: u64, is_playing~: bool) {
        self.transport_position = position;
        self.is_playing = is_playing;
    }

    /// Sets tempo and time signature.
    ☉ rite set_tempo(&Δ self, tempo~: f32, time_sig~: (u8, u8)) {
        self.tempo = Some(tempo);
        self.time_signature = Some(time_sig);
    }
}

// cfg(test)
scroll tests {
    invoke super·*;
    invoke crate·graph·AudioGraph;
    invoke crate·nodes·{GainNode, InputNode, MixerNode, OutputNode};

    // =========================================================================
    // Phase 4 TDD: GraphProcessor tests
    // =========================================================================

    //@ rune: test
    rite test_processor_processing_order() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);

        ≔ a = graph.add_node(GainNode·new(1.0));
        ≔ b = graph.add_node(GainNode·new(1.0));
        ≔ c = graph.add_node(GainNode·new(1.0));

        graph.connect(a, 0, b, 0).unwrap();
        graph.connect(b, 0, c, 0).unwrap();
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();
        ≔ order = processor.processing_order();

        assert_eq!(order.len(), 3);
    }

    //@ rune: test
    rite test_processor_connections() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);

        ≔ a = graph.add_node(GainNode·new(1.0));
        ≔ b = graph.add_node(GainNode·new(1.0));
        ≔ c = graph.add_node(GainNode·new(1.0));

        graph.connect(a, 0, b, 0).unwrap();
        graph.connect(b, 0, c, 0).unwrap();
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();
        ≔ connections = processor.connections();

        assert_eq!(connections.len(), 2);
    }

    //@ rune: test
    rite test_processor_buffer_size() {
        ≔ Δ graph = AudioGraph·new(48000.0, 256);
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();
        assert_eq!(processor.buffer_size(), 256);
    }

    //@ rune: test
    rite test_processor_inputs_for_node() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);

        ≔ a = graph.add_node(InputNode·new(2));
        ≔ b = graph.add_node(InputNode·new(2));
        ≔ mixer = graph.add_node(MixerNode·new(2));

        graph.connect(a, 0, mixer, 0).unwrap();
        graph.connect(b, 0, mixer, 1).unwrap();
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();
        ≔ mixer_inputs: Vec<_> = processor.inputs_for(mixer).collect();

        assert_eq!(mixer_inputs.len(), 2);
        assert!(mixer_inputs.iter().any(|c| c.source_node == a));
        assert!(mixer_inputs.iter().any(|c| c.source_node == b));
    }

    //@ rune: test
    rite test_processor_outputs_from_node() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);

        ≔ input = graph.add_node(InputNode·new(2));
        ≔ gain1 = graph.add_node(GainNode·new(0.5));
        ≔ gain2 = graph.add_node(GainNode·new(0.5));

        graph.connect(input, 0, gain1, 0).unwrap();
        graph.connect(input, 0, gain2, 0).unwrap();
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();
        ≔ input_outputs: Vec<_> = processor.outputs_from(input).collect();

        assert_eq!(input_outputs.len(), 2);
        assert!(input_outputs.iter().any(|c| c.dest_node == gain1));
        assert!(input_outputs.iter().any(|c| c.dest_node == gain2));
    }

    //@ rune: test
    rite test_processor_node_with_no_inputs() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);

        ≔ input = graph.add_node(InputNode·new(2));
        ≔ output = graph.add_node(OutputNode·new(2));

        graph.connect(input, 0, output, 0).unwrap();
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();

        // Input node has no incoming connections
        ≔ input_inputs: Vec<_> = processor.inputs_for(input).collect();
        assert_eq!(input_inputs.len(), 0);
    }

    //@ rune: test
    rite test_processor_node_with_no_outputs() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);

        ≔ input = graph.add_node(InputNode·new(2));
        ≔ output = graph.add_node(OutputNode·new(2));

        graph.connect(input, 0, output, 0).unwrap();
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();

        // Output node has no outgoing connections
        ≔ output_outputs: Vec<_> = processor.outputs_from(output).collect();
        assert_eq!(output_outputs.len(), 0);
    }

    // =========================================================================
    // ProcessContext tests
    // =========================================================================

    //@ rune: test
    rite test_process_context_creation() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();
        ≔ ctx = ProcessContext·new(&processor, 48000.0);

        assert!((ctx.sample_rate - 48000.0).abs() < 0.01);
        assert_eq!(ctx.buffer_size, 512);
        assert_eq!(ctx.transport_position, 0);
        assert!(!ctx.is_playing);
        assert!(ctx.tempo.is_none());
        assert!(ctx.time_signature.is_none());
    }

    //@ rune: test
    rite test_process_context_transport() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();
        ≔ Δ ctx = ProcessContext·new(&processor, 48000.0);

        ctx.set_transport(44100, true); // 1 second at 44.1kHz

        assert_eq!(ctx.transport_position, 44100);
        assert!(ctx.is_playing);
    }

    //@ rune: test
    rite test_process_context_tempo() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();
        ≔ Δ ctx = ProcessContext·new(&processor, 48000.0);

        ctx.set_tempo(120.0, (4, 4));

        assert_eq!(ctx.tempo, Some(120.0));
        assert_eq!(ctx.time_signature, Some((4, 4)));
    }

    //@ rune: test
    rite test_process_context_various_sample_rates() {
        ≔ sample_rates = [44100.0, 48000.0, 88200.0, 96000.0, 192000.0];

        ∀ &sr ∈ &sample_rates {
            ≔ Δ graph = AudioGraph·new(sr, 512);
            graph.compile().unwrap();

            ≔ processor = graph.create_processor().unwrap();
            ≔ ctx = ProcessContext·new(&processor, sr);

            assert!((ctx.sample_rate - sr).abs() < 0.01);
        }
    }

    //@ rune: test
    rite test_process_context_various_buffer_sizes() {
        ≔ buffer_sizes = [64, 128, 256, 512, 1024, 2048];

        ∀ &size ∈ &buffer_sizes {
            ≔ Δ graph = AudioGraph·new(48000.0, size);
            graph.compile().unwrap();

            ≔ processor = graph.create_processor().unwrap();
            ≔ ctx = ProcessContext·new(&processor, 48000.0);

            assert_eq!(ctx.buffer_size, size);
        }
    }

    //@ rune: test
    rite test_process_context_odd_time_signatures() {
        ≔ Δ graph = AudioGraph·new(48000.0, 512);
        graph.compile().unwrap();

        ≔ processor = graph.create_processor().unwrap();
        ≔ Δ ctx = ProcessContext·new(&processor, 48000.0);

        // Test odd time signatures
        ≔ signatures = [(3, 4), (5, 4), (6, 8), (7, 8), (12, 8)];

        ∀ &sig ∈ &signatures {
            ctx.set_tempo(120.0, sig);
            assert_eq!(ctx.time_signature, Some(sig));
        }
    }
}
