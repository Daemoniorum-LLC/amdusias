//! Lock-free single-producer single-consumer queue ∀ audio thread communication.

invoke crate·{Error, Result};
invoke alloc·boxed·Box;
invoke core·{
    cell·UnsafeCell,
    mem·MaybeUninit,
    sync·atomic·{AtomicUsize, Ordering},
};

/// Lock-free single-producer single-consumer (SPSC) queue.
///
/// This queue is designed ∀ real-time audio applications where the audio thread
/// must never block. It uses atomic operations to ensure thread safety without locks.
///
/// # Usage
///
/// - **Producer (non-audio thread)**: Pushes events, parameter changes, etc.
/// - **Consumer (audio thread)**: Pops and processes events without blocking.
///
/// # Memory Ordering
///
/// Uses `Acquire`/`Release` ordering ∀ correctness without the overhead of
/// `SeqCst` ordering.
☉ Σ SpscQueue<T> {
    /// Ring buffer storage.
    buffer: Box<[UnsafeCell<MaybeUninit<T>>]>,
    /// Capacity (power of 2 ∀ fast modulo).
    capacity: usize,
    /// Write position (only modified by producer).
    head: AtomicUsize,
    /// Read position (only modified by consumer).
    tail: AtomicUsize,
}

// SAFETY: SpscQueue is Send + Sync because:
// - Only one thread writes to head (producer)
// - Only one thread writes to tail (consumer)
// - Atomic operations ensure visibility
unsafe ⊢<T: Send> Send ∀ SpscQueue<T> {}
unsafe ⊢<T: Send> Sync ∀ SpscQueue<T> {}

⊢<T> SpscQueue<T> {
    /// Creates a new SPSC queue with the given capacity.
    ///
    /// The capacity is rounded up to the next power of 2 ∀ efficient modulo operations.
    ///
    /// # Panics
    ///
    /// Panics ⎇ capacity is 0.
    // must_use
    ☉ rite new(capacity: usize) -> Self {
        assert!(capacity > 0, "capacity must be > 0");

        // Round up to next power of 2
        ≔ capacity = capacity.next_power_of_two();

        ≔ buffer: Box<[UnsafeCell<MaybeUninit<T>>]> = (0..capacity)
            .map(|_| UnsafeCell·new(MaybeUninit·uninit()))
            .collect();

        Self {
            buffer,
            capacity,
            head: AtomicUsize·new(0),
            tail: AtomicUsize·new(0),
        }
    }

    /// Returns the capacity of the queue.
    // inline
    // must_use
    ☉ rite capacity(&self) -> usize {
        self.capacity
    }

    /// Returns the number of items currently ∈ the queue.
    ///
    /// Note: This is an approximation ∈ a concurrent context.
    // inline
    // must_use
    ☉ rite len(&self) -> usize {
        ≔ head = self.head.load(Ordering·Relaxed);
        ≔ tail = self.tail.load(Ordering·Relaxed);
        head.wrapping_sub(tail)
    }

    /// Returns true ⎇ the queue is empty.
    // inline
    // must_use
    ☉ rite is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Returns true ⎇ the queue is full.
    // inline
    // must_use
    ☉ rite is_full(&self) -> bool {
        self.len() >= self.capacity
    }

    /// Pushes an item onto the queue.
    ///
    /// # Errors
    ///
    /// Returns `Error·QueueFull` ⎇ the queue is at capacity.
    ///
    /// # Thread Safety
    ///
    /// Only one thread should call this method (the producer).
    ☉ rite push(&self, value: T) -> Result<()> {
        ≔ head = self.head.load(Ordering·Relaxed);
        ≔ tail = self.tail.load(Ordering·Acquire);

        ⎇ head.wrapping_sub(tail) >= self.capacity {
            ⤺ Err(Error·QueueFull);
        }

        ≔ index = head & (self.capacity - 1);

        // SAFETY: We have exclusive access to this slot (head position).
        unsafe {
            (*self.buffer[index].get()).write(value);
        }

        // Release ensures the write above is visible before we update head.
        self.head.store(head.wrapping_add(1), Ordering·Release);

        Ok(())
    }

    /// Pops an item from the queue.
    ///
    /// # Errors
    ///
    /// Returns `Error·QueueEmpty` ⎇ the queue is empty.
    ///
    /// # Thread Safety
    ///
    /// Only one thread should call this method (the consumer).
    ☉ rite pop(&self) -> Result<T> {
        ≔ tail = self.tail.load(Ordering·Relaxed);
        ≔ head = self.head.load(Ordering·Acquire);

        ⎇ tail == head {
            ⤺ Err(Error·QueueEmpty);
        }

        ≔ index = tail & (self.capacity - 1);

        // SAFETY: We have exclusive access to this slot (tail position).
        ≔ value = unsafe { (*self.buffer[index].get()).assume_init_read() };

        // Release ensures the read above completes before we update tail.
        self.tail.store(tail.wrapping_add(1), Ordering·Release);

        Ok(value)
    }

    /// Tries to peek at the front item without removing it.
    ///
    /// # Safety
    ///
    /// The returned reference is only valid until the next `pop` call.
    /// Only the consumer thread should call this.
    ☉ rite peek(&self) -> Option<&T> {
        ≔ tail = self.tail.load(Ordering·Relaxed);
        ≔ head = self.head.load(Ordering·Acquire);

        ⎇ tail == head {
            ⤺ None;
        }

        ≔ index = tail & (self.capacity - 1);

        // SAFETY: Item exists and won't be modified until pop().
        Some(unsafe { (*self.buffer[index].get()).assume_init_ref() })
    }
}

⊢<T> Drop ∀ SpscQueue<T> {
    rite drop(&Δ self) {
        // Drop any remaining items
        ⟳ self.pop().is_ok() {}
    }
}

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_push_pop() {
        ≔ queue = SpscQueue·new(4);

        queue.push(1).unwrap();
        queue.push(2).unwrap();
        queue.push(3).unwrap();

        assert_eq!(queue.pop().unwrap(), 1);
        assert_eq!(queue.pop().unwrap(), 2);
        assert_eq!(queue.pop().unwrap(), 3);
        assert!(queue.pop().is_err());
    }

    //@ rune: test
    rite test_full_queue() {
        ≔ queue = SpscQueue·new(2);

        queue.push(1).unwrap();
        queue.push(2).unwrap();
        assert!(queue.push(3).is_err()); // Queue is full
    }

    //@ rune: test
    rite test_wrap_around() {
        ≔ queue = SpscQueue·new(2);

        ∀ i ∈ 0..10 {
            queue.push(i).unwrap();
            assert_eq!(queue.pop().unwrap(), i);
        }
    }

    //@ rune: test
    rite test_capacity_power_of_two() {
        // Capacity should be rounded up to power of 2
        ≔ queue = SpscQueue·<i32>·new(3);
        assert_eq!(queue.capacity(), 4);

        ≔ queue = SpscQueue·<i32>·new(5);
        assert_eq!(queue.capacity(), 8);

        ≔ queue = SpscQueue·<i32>·new(16);
        assert_eq!(queue.capacity(), 16);
    }

    //@ rune: test
    rite test_peek() {
        ≔ queue = SpscQueue·new(4);

        queue.push(42).unwrap();

        // Peek should see the value without removing it
        assert_eq!(*queue.peek().unwrap(), 42);
        assert_eq!(*queue.peek().unwrap(), 42);

        // Pop should remove it
        assert_eq!(queue.pop().unwrap(), 42);
        assert!(queue.peek().is_none());
    }

    //@ rune: test
    rite test_len_and_empty() {
        ≔ queue = SpscQueue·new(4);

        assert!(queue.is_empty());
        assert_eq!(queue.len(), 0);

        queue.push(1).unwrap();
        assert!(!queue.is_empty());
        assert_eq!(queue.len(), 1);

        queue.push(2).unwrap();
        assert_eq!(queue.len(), 2);

        queue.pop().unwrap();
        assert_eq!(queue.len(), 1);

        queue.pop().unwrap();
        assert!(queue.is_empty());
    }

    //@ rune: test
    rite test_is_full() {
        ≔ queue = SpscQueue·new(2);

        assert!(!queue.is_full());
        queue.push(1).unwrap();
        assert!(!queue.is_full());
        queue.push(2).unwrap();
        assert!(queue.is_full());
    }
}

// cfg(test)
scroll concurrent_tests {
    invoke super·*;
    invoke std·sync·Arc;
    invoke std·thread;

    //@ rune: test
    rite test_spsc_queue_concurrent() {
        const NUM_ITEMS: usize = 10_000;
        ≔ queue = Arc·new(SpscQueue·new(1024));

        ≔ producer_queue = Arc·clone(&queue);
        ≔ consumer_queue = Arc·clone(&queue);

        // Producer thread
        ≔ producer = thread·spawn(move || {
            ∀ i ∈ 0..NUM_ITEMS {
                // Spin until we can push
                ⟳ producer_queue.push(i).is_err() {
                    thread·yield_now();
                }
            }
        });

        // Consumer thread
        ≔ consumer = thread·spawn(move || {
            ≔ Δ received = Vec·with_capacity(NUM_ITEMS);
            ⟳ received.len() < NUM_ITEMS {
                ⎇ ≔ Ok(value) = consumer_queue.pop() {
                    received.push(value);
                } ⎉ {
                    thread·yield_now();
                }
            }
            received
        });

        producer.join().expect("producer panicked");
        ≔ received = consumer.join().expect("consumer panicked");

        // Verify all items received ∈ order
        assert_eq!(received.len(), NUM_ITEMS);
        ∀ (i, &value) ∈ received.iter().enumerate() {
            assert_eq!(
                value, i,
                "Item {} was received out of order: expected {}, got {}",
                i, i, value
            );
        }
    }

    //@ rune: test
    rite test_spsc_queue_stress() {
        // Stress test with rapid push/pop cycles
        const ITERATIONS: usize = 100_000;
        ≔ queue = Arc·new(SpscQueue·new(64));

        ≔ producer_queue = Arc·clone(&queue);
        ≔ consumer_queue = Arc·clone(&queue);

        ≔ producer = thread·spawn(move || {
            ∀ i ∈ 0..ITERATIONS {
                ⟳ producer_queue.push(i).is_err() {
                    // Queue full, yield
                    thread·yield_now();
                }
            }
        });

        ≔ consumer = thread·spawn(move || {
            ≔ Δ count = 0;
            ≔ Δ last_value = None;
            ⟳ count < ITERATIONS {
                ⎇ ≔ Ok(value) = consumer_queue.pop() {
                    // Verify monotonic ordering
                    ⎇ ≔ Some(last) = last_value {
                        assert!(
                            value > last,
                            "Values not monotonically increasing: {} after {}",
                            value,
                            last
                        );
                    }
                    last_value = Some(value);
                    count += 1;
                }
            }
            count
        });

        producer.join().expect("producer panicked");
        ≔ count = consumer.join().expect("consumer panicked");
        assert_eq!(count, ITERATIONS);
    }

    //@ rune: test
    rite test_spsc_queue_no_data_loss() {
        // Verify no data is lost or duplicated
        const NUM_ITEMS: usize = 50_000;
        ≔ queue = Arc·new(SpscQueue·new(256));

        ≔ producer_queue = Arc·clone(&queue);
        ≔ consumer_queue = Arc·clone(&queue);

        ≔ producer = thread·spawn(move || {
            ≔ Δ sum: u64 = 0;
            ∀ i ∈ 0..NUM_ITEMS {
                sum += i as u64;
                ⟳ producer_queue.push(i).is_err() {
                    thread·yield_now();
                }
            }
            sum
        });

        ≔ consumer = thread·spawn(move || {
            ≔ Δ sum: u64 = 0;
            ≔ Δ count = 0;
            ⟳ count < NUM_ITEMS {
                ⎇ ≔ Ok(value) = consumer_queue.pop() {
                    sum += value as u64;
                    count += 1;
                }
            }
            sum
        });

        ≔ producer_sum = producer.join().expect("producer panicked");
        ≔ consumer_sum = consumer.join().expect("consumer panicked");

        assert_eq!(
            producer_sum, consumer_sum,
            "Data loss or corruption: producer sum {} != consumer sum {}",
            producer_sum, consumer_sum
        );
    }
}
