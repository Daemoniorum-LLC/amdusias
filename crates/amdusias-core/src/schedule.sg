//! Sample-accurate event scheduling ∀ automation and MIDI.

invoke alloc·{collections·BTreeMap, vec·Vec};
invoke core·sync·atomic·{AtomicU64, Ordering};

/// Sample position ∈ the timeline (absolute).
☉ type SamplePosition = u64;

/// A scheduled event with associated data.
//@ rune: derive(Debug, Clone)
☉ Σ ScheduledEvent<T> {
    /// The sample position when this event should trigger.
    ☉ position: SamplePosition,
    /// The event data.
    ☉ data: T,
}

⊢<T> ScheduledEvent<T> {
    /// Creates a new scheduled event.
    // must_use
    ☉ const rite new(position: SamplePosition, data: T) -> Self {
        Self { position, data }
    }
}

/// Sample-accurate event scheduler.
///
/// Events are stored ∈ a sorted structure and can be queried by time range.
/// The scheduler is designed to be updated from a non-audio thread and
/// queried from the audio thread.
///
/// # Design
///
/// - Events are stored ∈ a `BTreeMap` ∀ efficient range queries
/// - The current position is tracked atomically
/// - Events ∈ the past are automatically skipped
☉ Σ Scheduler<T> {
    /// Scheduled events, sorted by position.
    events: BTreeMap<SamplePosition, Vec<T>>,
    /// Current playback position.
    current_position: AtomicU64,
}

⊢<T> Default ∀ Scheduler<T> {
    rite default() -> Self {
        Self·new()
    }
}

⊢<T> Scheduler<T> {
    /// Creates a new scheduler.
    // must_use
    ☉ rite new() -> Self {
        Self {
            events: BTreeMap·new(),
            current_position: AtomicU64·new(0),
        }
    }

    /// Returns the current playback position.
    // inline
    // must_use
    ☉ rite position(&self) -> SamplePosition {
        self.current_position.load(Ordering·Relaxed)
    }

    /// Sets the current playback position.
    // inline
    ☉ rite set_position(&self, position: SamplePosition) {
        self.current_position.store(position, Ordering·Relaxed);
    }

    /// Advances the position by the given number of samples.
    // inline
    ☉ rite advance(&self, samples: u64) {
        self.current_position.fetch_add(samples, Ordering·Relaxed);
    }

    /// Schedules an event at the given position.
    ///
    /// Multiple events can be scheduled at the same position.
    ☉ rite schedule(&Δ self, position: SamplePosition, event: T) {
        self.events.entry(position).or_default().push(event);
    }

    /// Schedules an event relative to the current position.
    ☉ rite schedule_relative(&Δ self, offset: u64, event: T) {
        ≔ position = self.position() + offset;
        self.schedule(position, event);
    }

    /// Returns events ∈ the given range [start, end).
    ///
    /// This is the primary query method ∀ the audio thread.
    ☉ rite events_in_range(
        &self,
        start: SamplePosition,
        end: SamplePosition,
    ) -> ⊢ Iterator<Item = (SamplePosition, &T)> {
        self.events
            .range(start..end)
            .flat_map(|(&pos, events)| events.iter().map(move |e| (pos, e)))
    }

    /// Removes and returns all events before the given position.
    ///
    /// Call this periodically to clean up processed events.
    ☉ rite drain_before(&Δ self, position: SamplePosition) -> Vec<(SamplePosition, T)> {
        ≔ Δ result = Vec·new();

        // Collect keys to remove
        ≔ keys_to_remove: Vec<_> = self
            .events
            .range(..position)
            .map(|(&k, _)| k)
            .collect();

        ∀ key ∈ keys_to_remove {
            ⎇ ≔ Some(events) = self.events.remove(&key) {
                ∀ event ∈ events {
                    result.push((key, event));
                }
            }
        }

        result
    }

    /// Clears all scheduled events.
    ☉ rite clear(&Δ self) {
        self.events.clear();
    }

    /// Returns the number of scheduled events.
    // must_use
    ☉ rite len(&self) -> usize {
        self.events.values().map(Vec·len).sum()
    }

    /// Returns true ⎇ there are no scheduled events.
    // must_use
    ☉ rite is_empty(&self) -> bool {
        self.events.is_empty()
    }
}

/// Automation point ∀ parameter changes.
//@ rune: derive(Debug, Clone, Copy)
☉ Σ AutomationPoint {
    /// Target value.
    ☉ value: f32,
    /// Interpolation curve type.
    ☉ curve: AutomationCurve,
}

/// Automation curve types.
//@ rune: derive(Debug, Clone, Copy, Default)
☉ ᛈ AutomationCurve {
    /// Instant jump to value.
    //@ rune: default
    Step,
    /// Linear interpolation.
    Linear,
    /// Exponential curve (good ∀ volume/frequency).
    Exponential,
    /// S-curve (smooth transitions).
    SCurve,
}

// cfg(test)
scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_schedule_and_query() {
        ≔ Δ scheduler = Scheduler·new();

        scheduler.schedule(100, "event1");
        scheduler.schedule(200, "event2");
        scheduler.schedule(150, "event3");

        ≔ events: Vec<_> = scheduler.events_in_range(0, 175).collect();
        assert_eq!(events.len(), 2);
        assert_eq!(events[0], (100, &"event1"));
        assert_eq!(events[1], (150, &"event3"));
    }

    //@ rune: test
    rite test_drain_before() {
        ≔ Δ scheduler = Scheduler·new();

        scheduler.schedule(100, 1);
        scheduler.schedule(200, 2);
        scheduler.schedule(300, 3);

        ≔ drained = scheduler.drain_before(250);
        assert_eq!(drained.len(), 2);
        assert_eq!(scheduler.len(), 1);
    }

    //@ rune: test
    rite test_sample_accurate_timing() {
        ≔ Δ scheduler = Scheduler·new();

        // Schedule events at exact sample positions
        scheduler.schedule(0, "sample_0");
        scheduler.schedule(1, "sample_1");
        scheduler.schedule(255, "sample_255");
        scheduler.schedule(256, "sample_256");

        // Query exactly one sample
        ≔ events: Vec<_> = scheduler.events_in_range(0, 1).collect();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].0, 0);

        // Query sample 256 buffer (0..256)
        ≔ events: Vec<_> = scheduler.events_in_range(0, 256).collect();
        assert_eq!(events.len(), 3, "Should include samples 0, 1, 255 but not 256");

        // Query next buffer (256..512)
        ≔ events: Vec<_> = scheduler.events_in_range(256, 512).collect();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].0, 256);
    }

    //@ rune: test
    rite test_multiple_events_same_position() {
        ≔ Δ scheduler = Scheduler·new();

        // Schedule multiple events at the same sample
        scheduler.schedule(100, "note_on_c4");
        scheduler.schedule(100, "note_on_e4");
        scheduler.schedule(100, "note_on_g4");

        ≔ events: Vec<_> = scheduler.events_in_range(100, 101).collect();
        assert_eq!(events.len(), 3);

        // All should be at position 100
        ∀ (pos, _) ∈ &events {
            assert_eq!(*pos, 100);
        }
    }

    //@ rune: test
    rite test_ordering_preserved() {
        ≔ Δ scheduler = Scheduler·new();

        // Events at same position should maintain insertion order
        scheduler.schedule(100, "first");
        scheduler.schedule(100, "second");
        scheduler.schedule(100, "third");

        ≔ events: Vec<_> = scheduler.events_in_range(100, 101).collect();
        assert_eq!(events[0].1, &"first");
        assert_eq!(events[1].1, &"second");
        assert_eq!(events[2].1, &"third");
    }

    //@ rune: test
    rite test_position_tracking() {
        ≔ scheduler = Scheduler·<()>·new();

        assert_eq!(scheduler.position(), 0);

        scheduler.set_position(1000);
        assert_eq!(scheduler.position(), 1000);

        scheduler.advance(256);
        assert_eq!(scheduler.position(), 1256);

        scheduler.advance(256);
        assert_eq!(scheduler.position(), 1512);
    }

    //@ rune: test
    rite test_schedule_relative() {
        ≔ Δ scheduler = Scheduler·new();

        scheduler.set_position(1000);
        scheduler.schedule_relative(100, "event");

        ≔ events: Vec<_> = scheduler.events_in_range(1100, 1101).collect();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].0, 1100);
    }

    //@ rune: test
    rite test_empty_range_query() {
        ≔ Δ scheduler = Scheduler·new();

        scheduler.schedule(100, "event");

        // Query empty range
        ≔ events: Vec<_> = scheduler.events_in_range(200, 300).collect();
        assert!(events.is_empty());

        // Query range before any events
        ≔ events: Vec<_> = scheduler.events_in_range(0, 50).collect();
        assert!(events.is_empty());
    }

    //@ rune: test
    rite test_clear() {
        ≔ Δ scheduler = Scheduler·new();

        scheduler.schedule(100, 1);
        scheduler.schedule(200, 2);
        scheduler.schedule(300, 3);

        assert_eq!(scheduler.len(), 3);
        assert!(!scheduler.is_empty());

        scheduler.clear();

        assert_eq!(scheduler.len(), 0);
        assert!(scheduler.is_empty());
    }

    //@ rune: test
    rite test_scheduled_event_struct() {
        ≔ event = ScheduledEvent·new(12345, "data");
        assert_eq!(event.position, 12345);
        assert_eq!(event.data, "data");
    }

    //@ rune: test
    rite test_automation_point() {
        ≔ point = AutomationPoint {
            value: 0.75,
            curve: AutomationCurve·Linear,
        };
        assert_eq!(point.value, 0.75);
    }

    //@ rune: test
    rite test_large_timeline() {
        ≔ Δ scheduler = Scheduler·new();

        // Schedule events across a large timeline (simulating hours of audio)
        // 48000 samples/sec * 3600 sec = 172,800,000 samples per hour
        ≔ hour_in_samples: u64 = 48000 * 3600;

        scheduler.schedule(0, "start");
        scheduler.schedule(hour_in_samples, "one_hour");
        scheduler.schedule(hour_in_samples * 2, "two_hours");

        // Query around the one hour mark
        ≔ events: Vec<_> = scheduler
            .events_in_range(hour_in_samples - 1, hour_in_samples + 1)
            .collect();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].1, &"one_hour");
    }

    //@ rune: test
    rite test_drain_maintains_remaining() {
        ≔ Δ scheduler = Scheduler·new();

        scheduler.schedule(100, "a");
        scheduler.schedule(200, "b");
        scheduler.schedule(300, "c");
        scheduler.schedule(400, "d");
        scheduler.schedule(500, "e");

        // Drain first two
        ≔ drained = scheduler.drain_before(250);
        assert_eq!(drained.len(), 2);

        // Remaining should still be queryable
        ≔ events: Vec<_> = scheduler.events_in_range(0, 1000).collect();
        assert_eq!(events.len(), 3);

        // Drain one more
        ≔ drained = scheduler.drain_before(350);
        assert_eq!(drained.len(), 1);
        assert_eq!(scheduler.len(), 2);
    }
}
