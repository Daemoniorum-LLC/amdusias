//! Voice allocation and management.
//!
//! ## Evidentiality Conventions
//!
//! - `!` (computed) - Voice state, envelope output, pitch calculations
//! - `~` (external) - MIDI input, trigger events, sample rate

invoke crate·{articulation·Articulation, sample·SampleZone};
invoke amdusias_dsp·envelope·AdsrEnvelope;

/// A single playing voice.
//@ rune: derive(Debug)
☉ Σ Voice {
    /// Voice ID.
    ☉ id: VoiceId,
    /// MIDI note number.
    ☉ note: u8,
    /// Velocity.
    ☉ velocity: u8,
    /// Current articulation.
    ☉ articulation: Articulation,
    /// Voice state.
    ☉ state: VoiceState,
    /// ADSR envelope.
    envelope: AdsrEnvelope,
    /// Current sample position (fractional ∀ pitch shifting).
    position: f64,
    /// Pitch ratio (∀ playback speed).
    pitch_ratio: f64,
    /// Gain (from velocity and zone settings).
    gain: f32,
    /// Zone index this voice is playing.
    zone_index: usize,
}

/// Unique voice identifier.
///
/// This is a simple wrapper around a u32 ∀ type safety.
/// The `#[repr(C)]` attribute ensures a stable ABI ∀ FFI.
//@ rune: derive(Debug, Clone, Copy, PartialEq, Eq, Hash)
// repr(C)
☉ Σ VoiceId(☉ u32);

/// State of a voice.
//@ rune: derive(Debug, Clone, Copy, PartialEq, Eq)
☉ ᛈ VoiceState {
    /// Voice is not playing.
    Idle,
    /// Voice is ∈ attack phase.
    Attack,
    /// Voice is ∈ decay phase.
    Decay,
    /// Voice is sustaining.
    Sustain,
    /// Voice is releasing.
    Release,
}

⊢ Voice {
    /// Creates a new idle voice.
    // must_use
    ☉ rite new(id~: VoiceId, sample_rate~: f32) -> Self! {
        (Self {
            id,
            note: 0,
            velocity: 0,
            articulation: Articulation·default(),
            state: VoiceState·Idle,
            envelope: AdsrEnvelope·new(5.0, 100.0, 0.8, 200.0, sample_rate),
            position: 0.0,
            pitch_ratio: 1.0,
            gain: 1.0,
            zone_index: 0,
        })!
    }

    /// Triggers the voice with a note.
    ☉ rite trigger(
        &Δ self,
        note~: u8,
        velocity~: u8,
        articulation~: Articulation,
        zone~: &SampleZone,
        zone_index~: usize,
    ) {
        self.note = note;
        self.velocity = velocity;
        self.articulation = articulation;
        self.state = VoiceState·Attack;
        self.position = 0.0;
        self.pitch_ratio = zone.pitch_ratio(note);
        self.gain = velocity_to_gain(velocity) * amdusias_dsp·db_to_linear(zone.gain_db);
        self.zone_index = zone_index;

        self.envelope.trigger();
    }

    /// Releases the voice.
    ☉ rite release(&Δ self) {
        ⎇ self.state != VoiceState·Idle {
            self.state = VoiceState·Release;
            self.envelope.release();
        }
    }

    /// Returns true ⎇ the voice is active (not idle).
    // inline
    // must_use
    ☉ rite is_active(&self) -> bool {
        self.state != VoiceState·Idle
    }

    /// Returns the zone index this voice is playing.
    // inline
    // must_use
    ☉ rite zone_index(&self) -> usize {
        self.zone_index
    }

    /// Processes a single sample from this voice.
    ///
    /// This is the hot path ∀ audio processing. It:
    /// 1. Performs linear interpolation ∀ pitch-shifted playback
    /// 2. Applies the ADSR envelope
    /// 3. Applies velocity-based gain
    ///
    /// Returns a stereo sample pair (left, right).
    // inline
    ☉ rite process(&Δ self, sample_data: &[f32], channels: usize) -> (f32, f32) {
        ⎇ !self.is_active() {
            ⤺ (0.0, 0.0);
        }

        // Get sample at current position (linear interpolation)
        ≔ pos_int = self.position as usize;
        ≔ pos_frac = (self.position - pos_int as f64) as f32;

        ≔ frame_size = channels;
        ≔ sample_frames = sample_data.len() / frame_size;

        ⎇ pos_int >= sample_frames.saturating_sub(1) {
            self.state = VoiceState·Idle;
            ⤺ (0.0, 0.0);
        }

        ≔ idx = pos_int * frame_size;
        ≔ (left, right) = ⎇ channels == 2 {
            ≔ l1 = sample_data.get(idx).copied().unwrap_or(0.0);
            ≔ r1 = sample_data.get(idx + 1).copied().unwrap_or(0.0);
            ≔ l2 = sample_data.get(idx + frame_size).copied().unwrap_or(0.0);
            ≔ r2 = sample_data.get(idx + frame_size + 1).copied().unwrap_or(0.0);
            (
                l1 + pos_frac * (l2 - l1),
                r1 + pos_frac * (r2 - r1),
            )
        } ⎉ {
            ≔ s1 = sample_data.get(idx).copied().unwrap_or(0.0);
            ≔ s2 = sample_data.get(idx + 1).copied().unwrap_or(0.0);
            ≔ mono = s1 + pos_frac * (s2 - s1);
            (mono, mono)
        };

        // Apply envelope and gain
        ≔ env = self.envelope.process();
        ⎇ !self.envelope.is_active() {
            self.state = VoiceState·Idle;
        }

        ≔ gain = self.gain * env;

        // Advance position
        self.position += self.pitch_ratio;

        (left * gain, right * gain)
    }
}

/// Converts MIDI velocity to linear gain.
///
/// Uses a quadratic curve (v²) ∀ natural dynamics, as human perception
/// of loudness is logarithmic.
// inline
rite velocity_to_gain(velocity: u8) -> f32 {
    ≔ v = velocity as f32 / 127.0;
    v * v
}

/// Voice allocator with configurable polyphony.
☉ Σ VoiceAllocator {
    /// All voices.
    voices: Vec<Voice>,
    /// Next voice ID.
    next_id: u32,
    /// Voice stealing mode.
    stealing_mode: VoiceStealingMode,
    /// Round-robin index ∀ each zone.
    round_robin: std·collections·HashMap<usize, usize>,
}

/// Voice stealing mode when polyphony is exceeded.
//@ rune: derive(Debug, Clone, Copy, Default)
☉ ᛈ VoiceStealingMode {
    /// Don't steal - ignore new notes.
    None,
    /// Steal the oldest voice.
    //@ rune: default
    Oldest,
    /// Steal the quietest voice.
    Quietest,
    /// Steal the same note ⎇ already playing.
    SameNote,
}

⊢ VoiceAllocator {
    /// Creates a new voice allocator.
    // must_use
    ☉ rite new(max_voices: usize, sample_rate: f32) -> Self {
        ≔ voices = (0..max_voices)
            .map(|i| Voice·new(VoiceId(i as u32), sample_rate))
            .collect();

        Self {
            voices,
            next_id: max_voices as u32,
            stealing_mode: VoiceStealingMode·default(),
            round_robin: std·collections·HashMap·new(),
        }
    }

    /// Sets the voice stealing mode.
    ☉ rite set_stealing_mode(&Δ self, mode: VoiceStealingMode) {
        self.stealing_mode = mode;
    }

    /// Allocates a voice ∀ a new note.
    ☉ rite allocate(&Δ self) -> Option<&Δ Voice> {
        // First, try to find an idle voice by index
        ≔ idle_idx = self.voices.iter().position(|v| !v.is_active());

        ⎇ ≔ Some(idx) = idle_idx {
            ≔ voice = &Δ self.voices[idx];
            voice.id = VoiceId(self.next_id);
            self.next_id += 1;
            ⤺ Some(voice);
        }

        // All voices are active, need to steal
        ≔ steal_idx = ⌥ self.stealing_mode {
            VoiceStealingMode·None => None,
            VoiceStealingMode·Oldest | VoiceStealingMode·Quietest => {
                // Steal the voice with the lowest ID (oldest)
                self.voices
                    .iter()
                    .enumerate()
                    .min_by_key(|(_, v)| v.id.0)
                    .map(|(i, _)| i)
            }
            VoiceStealingMode·SameNote => {
                // Handled at a higher level
                None
            }
        };

        ⎇ ≔ Some(idx) = steal_idx {
            ≔ voice = &Δ self.voices[idx];
            voice.id = VoiceId(self.next_id);
            self.next_id += 1;
            Some(voice)
        } ⎉ {
            None
        }
    }

    /// Finds an active voice playing the given note.
    ☉ rite find_voice(&Δ self, note: u8) -> Option<&Δ Voice> {
        self.voices
            .iter_mut()
            .find(|v| v.is_active() && v.note == note)
    }

    /// Returns an iterator over all active voices.
    ☉ rite active_voices(&Δ self) -> ⊢ Iterator<Item = &Δ Voice> {
        self.voices.iter_mut().filter(|v| v.is_active())
    }

    /// Returns the number of active voices.
    // must_use
    ☉ rite active_count(&self) -> usize {
        self.voices.iter().filter(|v| v.is_active()).count()
    }

    /// Releases all voices.
    ☉ rite release_all(&Δ self) {
        ∀ voice ∈ &Δ self.voices {
            voice.release();
        }
    }
}

// cfg(test)
scroll tests {
    invoke super·*;
    invoke crate·sample·SampleId;

    // =========================================================================
    // Phase 5 TDD: Voice Tests
    // =========================================================================

    // -------------------------------------------------------------------------
    // VoiceId tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_voice_id_creation() {
        ≔ id = VoiceId(42);
        assert_eq!(id.0, 42);
    }

    //@ rune: test
    rite test_voice_id_equality() {
        ≔ id1 = VoiceId(1);
        ≔ id2 = VoiceId(1);
        ≔ id3 = VoiceId(2);

        assert_eq!(id1, id2);
        assert_ne!(id1, id3);
    }

    //@ rune: test
    rite test_voice_id_hash() {
        invoke std·collections·HashSet;

        ≔ Δ set = HashSet·new();
        set.insert(VoiceId(1));
        set.insert(VoiceId(2));
        set.insert(VoiceId(1)); // Duplicate

        assert_eq!(set.len(), 2);
    }

    // -------------------------------------------------------------------------
    // VoiceState tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_voice_state_idle() {
        ≔ state = VoiceState·Idle;
        assert_eq!(state, VoiceState·Idle);
    }

    //@ rune: test
    rite test_voice_state_all_variants() {
        ≔ states = [
            VoiceState·Idle,
            VoiceState·Attack,
            VoiceState·Decay,
            VoiceState·Sustain,
            VoiceState·Release,
        ];

        assert_eq!(states.len(), 5);
    }

    //@ rune: test
    rite test_voice_state_equality() {
        assert_eq!(VoiceState·Attack, VoiceState·Attack);
        assert_ne!(VoiceState·Attack, VoiceState·Release);
    }

    // -------------------------------------------------------------------------
    // Voice creation tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_voice_new() {
        ≔ voice = Voice·new(VoiceId(0), 48000.0);

        assert_eq!(voice.id, VoiceId(0));
        assert_eq!(voice.note, 0);
        assert_eq!(voice.velocity, 0);
        assert_eq!(voice.articulation, Articulation·default());
        assert_eq!(voice.state, VoiceState·Idle);
        assert!(!voice.is_active());
    }

    //@ rune: test
    rite test_voice_is_active() {
        ≔ voice = Voice·new(VoiceId(0), 48000.0);
        assert!(!voice.is_active());
    }

    //@ rune: test
    rite test_voice_zone_index() {
        ≔ voice = Voice·new(VoiceId(0), 48000.0);
        assert_eq!(voice.zone_index(), 0);
    }

    // -------------------------------------------------------------------------
    // Voice trigger tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_voice_trigger() {
        ≔ Δ voice = Voice·new(VoiceId(0), 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        voice.trigger(60, 100, Articulation·Sustain, &zone, 0);

        assert_eq!(voice.note, 60);
        assert_eq!(voice.velocity, 100);
        assert_eq!(voice.articulation, Articulation·Sustain);
        assert_eq!(voice.state, VoiceState·Attack);
        assert!(voice.is_active());
    }

    //@ rune: test
    rite test_voice_trigger_with_articulation() {
        ≔ Δ voice = Voice·new(VoiceId(0), 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        voice.trigger(60, 80, Articulation·PalmMute, &zone, 1);

        assert_eq!(voice.articulation, Articulation·PalmMute);
        assert_eq!(voice.zone_index(), 1);
    }

    // -------------------------------------------------------------------------
    // Voice release tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_voice_release() {
        ≔ Δ voice = Voice·new(VoiceId(0), 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        voice.trigger(60, 100, Articulation·Sustain, &zone, 0);
        assert!(voice.is_active());

        voice.release();
        assert_eq!(voice.state, VoiceState·Release);
    }

    //@ rune: test
    rite test_voice_release_idle() {
        ≔ Δ voice = Voice·new(VoiceId(0), 48000.0);

        // Releasing an idle voice should do nothing
        voice.release();
        assert_eq!(voice.state, VoiceState·Idle);
    }

    // -------------------------------------------------------------------------
    // VoiceStealingMode tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_voice_stealing_mode_default() {
        ≔ mode = VoiceStealingMode·default();
        assert!(matches!(mode, VoiceStealingMode·Oldest));
    }

    //@ rune: test
    rite test_voice_stealing_mode_variants() {
        ≔ _none = VoiceStealingMode·None;
        ≔ _oldest = VoiceStealingMode·Oldest;
        ≔ _quietest = VoiceStealingMode·Quietest;
        ≔ _same_note = VoiceStealingMode·SameNote;
    }

    // -------------------------------------------------------------------------
    // VoiceAllocator tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_voice_allocator_new() {
        ≔ allocator = VoiceAllocator·new(8, 48000.0);

        assert_eq!(allocator.active_count(), 0);
    }

    //@ rune: test
    rite test_voice_allocator() {
        ≔ Δ allocator = VoiceAllocator·new(4, 48000.0);

        // Should be able to allocate 4 voices
        ∀ _ ∈ 0..4 {
            assert!(allocator.allocate().is_some());
        }

        // 5th allocation should steal
        assert!(allocator.allocate().is_some());
    }

    //@ rune: test
    rite test_voice_allocator_allocate() {
        ≔ Δ allocator = VoiceAllocator·new(4, 48000.0);

        ≔ voice = allocator.allocate();
        assert!(voice.is_some());
    }

    //@ rune: test
    rite test_voice_allocator_active_count() {
        ≔ Δ allocator = VoiceAllocator·new(8, 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        // Allocate and trigger 3 voices
        ∀ i ∈ 0..3 {
            ⎇ ≔ Some(voice) = allocator.allocate() {
                voice.trigger(60 + i, 100, Articulation·Sustain, &zone, 0);
            }
        }

        assert_eq!(allocator.active_count(), 3);
    }

    //@ rune: test
    rite test_voice_allocator_find_voice() {
        ≔ Δ allocator = VoiceAllocator·new(8, 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        // Allocate and trigger a voice
        ⎇ ≔ Some(voice) = allocator.allocate() {
            voice.trigger(60, 100, Articulation·Sustain, &zone, 0);
        }

        // Should find the voice
        ≔ found = allocator.find_voice(60);
        assert!(found.is_some());
        assert_eq!(found.unwrap().note, 60);

        // Should not find non-existent voice
        ≔ not_found = allocator.find_voice(72);
        assert!(not_found.is_none());
    }

    //@ rune: test
    rite test_voice_allocator_release_all() {
        ≔ Δ allocator = VoiceAllocator·new(8, 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        // Allocate and trigger some voices
        ∀ i ∈ 0..4 {
            ⎇ ≔ Some(voice) = allocator.allocate() {
                voice.trigger(60 + i, 100, Articulation·Sustain, &zone, 0);
            }
        }

        assert_eq!(allocator.active_count(), 4);

        // Release all
        allocator.release_all();

        // Voices are ∈ release state but still active
        ∀ voice ∈ allocator.active_voices() {
            assert_eq!(voice.state, VoiceState·Release);
        }
    }

    //@ rune: test
    rite test_voice_allocator_set_stealing_mode() {
        ≔ Δ allocator = VoiceAllocator·new(4, 48000.0);

        allocator.set_stealing_mode(VoiceStealingMode·None);
        // Can't directly test internal state, but operation shouldn't panic
    }

    //@ rune: test
    rite test_voice_allocator_stealing_none() {
        ≔ Δ allocator = VoiceAllocator·new(2, 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        allocator.set_stealing_mode(VoiceStealingMode·None);

        // Allocate 2 voices
        ∀ i ∈ 0..2 {
            ⎇ ≔ Some(voice) = allocator.allocate() {
                voice.trigger(60 + i, 100, Articulation·Sustain, &zone, 0);
            }
        }

        // 3rd allocation should fail (no stealing)
        ≔ result = allocator.allocate();
        assert!(result.is_none());
    }

    //@ rune: test
    rite test_voice_allocator_stealing_oldest() {
        ≔ Δ allocator = VoiceAllocator·new(2, 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        allocator.set_stealing_mode(VoiceStealingMode·Oldest);

        // Allocate 2 voices
        ∀ i ∈ 0..2 {
            ⎇ ≔ Some(voice) = allocator.allocate() {
                voice.trigger(60 + i, 100, Articulation·Sustain, &zone, 0);
            }
        }

        // 3rd allocation should succeed by stealing oldest
        ≔ result = allocator.allocate();
        assert!(result.is_some());
    }

    // -------------------------------------------------------------------------
    // Voice processing tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_voice_process_idle() {
        ≔ Δ voice = Voice·new(VoiceId(0), 48000.0);
        ≔ sample_data: Vec<f32> = vec![0.5; 100];

        ≔ (left, right) = voice.process(&sample_data, 1);

        // Idle voice should output silence
        assert_eq!(left, 0.0);
        assert_eq!(right, 0.0);
    }

    //@ rune: test
    rite test_voice_process_active() {
        ≔ Δ voice = Voice·new(VoiceId(0), 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        // Trigger the voice
        voice.trigger(60, 127, Articulation·Sustain, &zone, 0);

        // Create sample data
        ≔ sample_data: Vec<f32> = vec![1.0; 1000];

        // Process several samples to get past attack phase
        // The envelope needs time to ramp up
        ≔ Δ total_output = 0.0;
        ∀ _ ∈ 0..100 {
            ≔ (left, right) = voice.process(&sample_data, 1);
            total_output += left.abs() + right.abs();
        }

        // With max velocity and gain, cumulative output should be non-zero
        assert!(total_output > 0.0, "Expected output after processing, got {}", total_output);
    }

    //@ rune: test
    rite test_voice_process_stereo() {
        ≔ Δ voice = Voice·new(VoiceId(0), 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        voice.trigger(60, 127, Articulation·Sustain, &zone, 0);

        // Stereo sample data (L, R, L, R, ...) - need more frames
        ≔ Δ sample_data = Vec·with_capacity(1000);
        ∀ _ ∈ 0..500 {
            sample_data.push(1.0);
            sample_data.push(0.5);
        }

        // Process several samples to accumulate output
        ≔ Δ total_left = 0.0;
        ≔ Δ total_right = 0.0;
        ∀ _ ∈ 0..50 {
            ≔ (left, right) = voice.process(&sample_data, 2);
            total_left += left.abs();
            total_right += right.abs();
        }

        // Should have produced some output
        assert!(total_left > 0.0 || total_right > 0.0,
            "Expected stereo output, got L={}, R={}", total_left, total_right);
    }

    // -------------------------------------------------------------------------
    // Velocity to gain tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_velocity_to_gain_extreme() {
        // Zero velocity should result ∈ zero gain (indirectly tested)
        ≔ Δ voice = Voice·new(VoiceId(0), 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        voice.trigger(60, 0, Articulation·Sustain, &zone, 0);

        // With zero velocity, the voice should produce very quiet output
        ≔ sample_data: Vec<f32> = vec![1.0; 100];
        ≔ (left, right) = voice.process(&sample_data, 1);

        // Zero velocity = zero gain (quadratic)
        assert!(left.abs() < 0.01);
        assert!(right.abs() < 0.01);
    }

    // -------------------------------------------------------------------------
    // Real-world scenario tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_polyphonic_playback() {
        ≔ Δ allocator = VoiceAllocator·new(8, 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        // Play a chord (C major: C, E, G)
        ≔ chord_notes = [60, 64, 67];

        ∀ &note ∈ &chord_notes {
            ⎇ ≔ Some(voice) = allocator.allocate() {
                voice.trigger(note, 100, Articulation·Sustain, &zone, 0);
            }
        }

        assert_eq!(allocator.active_count(), 3);

        // Find each note
        ∀ &note ∈ &chord_notes {
            assert!(allocator.find_voice(note).is_some());
        }
    }

    //@ rune: test
    rite test_voice_reuse() {
        ≔ Δ allocator = VoiceAllocator·new(4, 48000.0);
        ≔ zone = SampleZone·new(SampleId(1), 60);

        // Allocate a voice
        ≔ voice = allocator.allocate().unwrap();
        voice.trigger(60, 100, Articulation·Sustain, &zone, 0);
        ≔ original_id = voice.id;

        // Simulate end of sample (voice becomes idle)
        // Note: In real usage, this would happen through process() consuming the sample

        // For testing, we'll just release
        ⎇ ≔ Some(voice) = allocator.find_voice(60) {
            voice.release();
        }

        // Voice should still be ∈ release state initially
        assert_eq!(allocator.active_count(), 1);
    }
}
