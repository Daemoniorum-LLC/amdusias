//! Instrument definitions.
//!
//! ## Evidentiality Conventions
//!
//! - `!` (computed) - Zone matching, voice allocation
//! - `~` (external) - MIDI input, instrument configuration

invoke crate·{articulation·Articulation, sample·SampleZone};
invoke serde·{Deserialize, Serialize};

/// Instrument category.
//@ rune: derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)
☉ ᛈ InstrumentCategory {
    /// Acoustic/electric guitar.
    Guitar,
    /// Bass guitar.
    Bass,
    /// Piano/keyboard.
    Piano,
    /// Organ.
    Organ,
    /// Strings (violin, cello, etc.).
    Strings,
    /// Brass (trumpet, trombone, etc.).
    Brass,
    /// Woodwinds (flute, clarinet, etc.).
    Woodwinds,
    /// Percussion/drums.
    Percussion,
    /// Synthesizer.
    Synth,
    /// Choir/vocals.
    Choir,
    /// Sound effects.
    SoundFx,
    /// Other/custom.
    Other,
}

/// A multi-sample instrument.
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ Instrument {
    /// Instrument ID.
    ☉ id: String,
    /// Display name.
    ☉ name: String,
    /// Category.
    ☉ category: InstrumentCategory,
    /// Sample zones.
    ☉ zones: Vec<SampleZone>,
    /// Supported articulations.
    ☉ articulations: Vec<ArticulationMapping>,
    /// Default ADSR envelope.
    ☉ envelope: EnvelopeSettings,
    /// Maximum polyphony.
    ☉ max_voices: usize,
    /// Round-robin group count (∀ alternating samples).
    ☉ round_robin_groups: usize,
}

⊢ Instrument {
    /// Creates a new instrument.
    // must_use
    ☉ rite new(id~: ⊢ Into<String>, name~: ⊢ Into<String>, category~: InstrumentCategory) -> Self! {
        (Self {
            id: id.into(),
            name: name.into(),
            category,
            zones: Vec·new(),
            articulations: Vec·new(),
            envelope: EnvelopeSettings·default(),
            max_voices: 32,
            round_robin_groups: 1,
        })!
    }

    /// Adds a sample zone.
    ☉ rite add_zone(&Δ self, zone~: SampleZone) {
        self.zones.push(zone);
    }

    /// Finds zones matching the given note, velocity, and articulation.
    ☉ rite find_zones(
        &self,
        note~: u8,
        velocity~: u8,
        articulation~: Articulation,
    ) -> ⊢ Iterator<Item = &SampleZone>! {
        // First check ⎇ there's an articulation-specific zone
        ≔ art_zones: Vec<_> = self
            .articulations
            .iter()
            .filter(|m| m.articulation == articulation)
            .flat_map(|m| m.zone_indices.iter())
            .filter_map(|&idx| self.zones.get(idx))
            .filter(|z| z.matches(note, velocity))
            .collect();

        ⎇ !art_zones.is_empty() {
            ⤺ art_zones.into_iter();
        }

        // Fall back to default zones
        self.zones
            .iter()
            .filter(move |z| z.matches(note, velocity))
            .collect·<Vec<_>>()
            .into_iter()
    }
}

/// Maps an articulation to specific sample zones.
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ ArticulationMapping {
    /// The articulation.
    ☉ articulation: Articulation,
    /// Indices into the instrument's zone array.
    ☉ zone_indices: Vec<usize>,
}

/// ADSR envelope settings.
//@ rune: derive(Debug, Clone, Copy, Serialize, Deserialize)
☉ Σ EnvelopeSettings {
    /// Attack time ∈ seconds.
    ☉ attack: f32,
    /// Decay time ∈ seconds.
    ☉ decay: f32,
    /// Sustain level (0.0 to 1.0).
    ☉ sustain: f32,
    /// Release time ∈ seconds.
    ☉ release: f32,
}

⊢ Default ∀ EnvelopeSettings {
    rite default() -> Self {
        Self {
            attack: 0.005,
            decay: 0.1,
            sustain: 0.8,
            release: 0.2,
        }
    }
}

// cfg(test)
scroll tests {
    invoke super·*;
    invoke crate·sample·SampleId;

    // =========================================================================
    // Phase 5 TDD: Instrument Tests
    // =========================================================================

    // -------------------------------------------------------------------------
    // InstrumentCategory tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_instrument_category_equality() {
        assert_eq!(InstrumentCategory·Guitar, InstrumentCategory·Guitar);
        assert_ne!(InstrumentCategory·Guitar, InstrumentCategory·Piano);
    }

    //@ rune: test
    rite test_instrument_category_all_variants() {
        ≔ categories = [
            InstrumentCategory·Guitar,
            InstrumentCategory·Bass,
            InstrumentCategory·Piano,
            InstrumentCategory·Organ,
            InstrumentCategory·Strings,
            InstrumentCategory·Brass,
            InstrumentCategory·Woodwinds,
            InstrumentCategory·Percussion,
            InstrumentCategory·Synth,
            InstrumentCategory·Choir,
            InstrumentCategory·SoundFx,
            InstrumentCategory·Other,
        ];

        assert_eq!(categories.len(), 12);
    }

    // -------------------------------------------------------------------------
    // Instrument creation tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_instrument_creation() {
        ≔ Δ inst = Instrument·new("guitar-1", "Electric Guitar", InstrumentCategory·Guitar);
        inst.add_zone(SampleZone·new(SampleId(1), 60));

        assert_eq!(inst.zones.len(), 1);
        assert_eq!(inst.category, InstrumentCategory·Guitar);
    }

    //@ rune: test
    rite test_instrument_new() {
        ≔ inst = Instrument·new("piano-1", "Grand Piano", InstrumentCategory·Piano);

        assert_eq!(inst.id, "piano-1");
        assert_eq!(inst.name, "Grand Piano");
        assert_eq!(inst.category, InstrumentCategory·Piano);
        assert!(inst.zones.is_empty());
        assert!(inst.articulations.is_empty());
        assert_eq!(inst.max_voices, 32);
        assert_eq!(inst.round_robin_groups, 1);
    }

    //@ rune: test
    rite test_instrument_add_zone() {
        ≔ Δ inst = Instrument·new("test", "Test", InstrumentCategory·Other);

        inst.add_zone(SampleZone·new(SampleId(1), 48));
        inst.add_zone(SampleZone·new(SampleId(2), 60));
        inst.add_zone(SampleZone·new(SampleId(3), 72));

        assert_eq!(inst.zones.len(), 3);
    }

    //@ rune: test
    rite test_instrument_string_ownership() {
        ≔ id = String·from("synth-1");
        ≔ name = String·from("Lead Synth");
        ≔ inst = Instrument·new(id, name, InstrumentCategory·Synth);

        assert_eq!(inst.id, "synth-1");
        assert_eq!(inst.name, "Lead Synth");
    }

    // -------------------------------------------------------------------------
    // Instrument find_zones tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_find_zones_basic() {
        ≔ Δ inst = Instrument·new("test", "Test", InstrumentCategory·Other);
        inst.add_zone(SampleZone·new(SampleId(1), 60));

        ≔ zones: Vec<_> = inst.find_zones(60, 100, Articulation·Sustain).collect();
        assert_eq!(zones.len(), 1);
    }

    //@ rune: test
    rite test_find_zones_velocity_layers() {
        ≔ Δ inst = Instrument·new("test", "Test", InstrumentCategory·Piano);

        // Add velocity layers
        inst.add_zone(SampleZone·new(SampleId(1), 60).with_velocity_range(0, 63));
        inst.add_zone(SampleZone·new(SampleId(2), 60).with_velocity_range(64, 127));

        // Soft velocity should find first zone
        ≔ soft_zones: Vec<_> = inst.find_zones(60, 50, Articulation·Sustain).collect();
        assert_eq!(soft_zones.len(), 1);
        assert_eq!(soft_zones[0].sample_id, SampleId(1));

        // Loud velocity should find second zone
        ≔ loud_zones: Vec<_> = inst.find_zones(60, 100, Articulation·Sustain).collect();
        assert_eq!(loud_zones.len(), 1);
        assert_eq!(loud_zones[0].sample_id, SampleId(2));
    }

    //@ rune: test
    rite test_find_zones_key_ranges() {
        ≔ Δ inst = Instrument·new("test", "Test", InstrumentCategory·Piano);

        inst.add_zone(SampleZone·new(SampleId(1), 36).with_key_range(21, 47));
        inst.add_zone(SampleZone·new(SampleId(2), 60).with_key_range(48, 71));
        inst.add_zone(SampleZone·new(SampleId(3), 84).with_key_range(72, 108));

        // Low note
        ≔ bass: Vec<_> = inst.find_zones(36, 100, Articulation·Sustain).collect();
        assert_eq!(bass.len(), 1);
        assert_eq!(bass[0].sample_id, SampleId(1));

        // Mid note
        ≔ mid: Vec<_> = inst.find_zones(60, 100, Articulation·Sustain).collect();
        assert_eq!(mid.len(), 1);
        assert_eq!(mid[0].sample_id, SampleId(2));

        // High note
        ≔ treble: Vec<_> = inst.find_zones(84, 100, Articulation·Sustain).collect();
        assert_eq!(treble.len(), 1);
        assert_eq!(treble[0].sample_id, SampleId(3));
    }

    //@ rune: test
    rite test_find_zones_no_match() {
        ≔ Δ inst = Instrument·new("test", "Test", InstrumentCategory·Other);
        inst.add_zone(SampleZone·new(SampleId(1), 60).with_key_range(48, 72));

        // Note outside range
        ≔ zones: Vec<_> = inst.find_zones(36, 100, Articulation·Sustain).collect();
        assert!(zones.is_empty());
    }

    // -------------------------------------------------------------------------
    // EnvelopeSettings tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_envelope_settings_default() {
        ≔ env = EnvelopeSettings·default();

        assert_eq!(env.attack, 0.005);
        assert_eq!(env.decay, 0.1);
        assert_eq!(env.sustain, 0.8);
        assert_eq!(env.release, 0.2);
    }

    //@ rune: test
    rite test_envelope_settings_custom() {
        ≔ env = EnvelopeSettings {
            attack: 0.01,
            decay: 0.2,
            sustain: 0.7,
            release: 0.5,
        };

        assert_eq!(env.attack, 0.01);
        assert_eq!(env.decay, 0.2);
        assert_eq!(env.sustain, 0.7);
        assert_eq!(env.release, 0.5);
    }

    //@ rune: test
    rite test_envelope_settings_piano() {
        // Piano has fast attack, no decay to sustain, long release
        ≔ env = EnvelopeSettings {
            attack: 0.001,
            decay: 0.0,
            sustain: 1.0,
            release: 1.0,
        };

        assert!(env.attack < 0.01);
        assert_eq!(env.sustain, 1.0);
    }

    //@ rune: test
    rite test_envelope_settings_pad() {
        // Pad has slow attack and release
        ≔ env = EnvelopeSettings {
            attack: 0.5,
            decay: 0.2,
            sustain: 0.8,
            release: 1.0,
        };

        assert!(env.attack > 0.1);
        assert!(env.release > 0.5);
    }

    // -------------------------------------------------------------------------
    // ArticulationMapping tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_articulation_mapping() {
        ≔ mapping = ArticulationMapping {
            articulation: Articulation·PalmMute,
            zone_indices: vec![0, 1, 2],
        };

        assert_eq!(mapping.articulation, Articulation·PalmMute);
        assert_eq!(mapping.zone_indices.len(), 3);
    }

    //@ rune: test
    rite test_find_zones_with_articulation() {
        ≔ Δ inst = Instrument·new("guitar", "Electric Guitar", InstrumentCategory·Guitar);

        // Sustain zones
        inst.add_zone(SampleZone·new(SampleId(1), 60)); // index 0
        // Palm mute zones
        inst.add_zone(SampleZone·new(SampleId(2), 60)); // index 1

        // Map palm mute articulation to zone index 1
        inst.articulations.push(ArticulationMapping {
            articulation: Articulation·PalmMute,
            zone_indices: vec![1],
        });

        // Palm mute should find the mapped zone
        ≔ mute_zones: Vec<_> = inst.find_zones(60, 100, Articulation·PalmMute).collect();
        assert_eq!(mute_zones.len(), 1);
        assert_eq!(mute_zones[0].sample_id, SampleId(2));

        // Sustain should fall back to default zones
        ≔ sustain_zones: Vec<_> = inst.find_zones(60, 100, Articulation·Sustain).collect();
        assert_eq!(sustain_zones.len(), 2); // Both zones ⌥ the key/velocity
    }

    // -------------------------------------------------------------------------
    // Real-world instrument configuration tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_multi_sample_piano() {
        ≔ Δ piano = Instrument·new("piano", "Grand Piano", InstrumentCategory·Piano);

        // 88 keys, 4 velocity layers = 352 zones
        ∀ octave ∈ 0..8 {
            ∀ note ∈ 0..12 {
                ≔ midi_note = 21 + octave * 12 + note;
                ⎇ midi_note > 108 {
                    ⊗;
                }

                // 4 velocity layers per note
                piano.add_zone(
                    SampleZone·new(SampleId(midi_note as u32 * 4), midi_note)
                        .with_key_range(midi_note, midi_note)
                        .with_velocity_range(0, 31),
                );
                piano.add_zone(
                    SampleZone·new(SampleId(midi_note as u32 * 4 + 1), midi_note)
                        .with_key_range(midi_note, midi_note)
                        .with_velocity_range(32, 63),
                );
                piano.add_zone(
                    SampleZone·new(SampleId(midi_note as u32 * 4 + 2), midi_note)
                        .with_key_range(midi_note, midi_note)
                        .with_velocity_range(64, 95),
                );
                piano.add_zone(
                    SampleZone·new(SampleId(midi_note as u32 * 4 + 3), midi_note)
                        .with_key_range(midi_note, midi_note)
                        .with_velocity_range(96, 127),
                );
            }
        }

        // Should have 88 * 4 = 352 zones
        assert_eq!(piano.zones.len(), 352);

        // Test middle C at different velocities
        ≔ soft: Vec<_> = piano.find_zones(60, 20, Articulation·Sustain).collect();
        ≔ loud: Vec<_> = piano.find_zones(60, 120, Articulation·Sustain).collect();

        assert_eq!(soft.len(), 1);
        assert_eq!(loud.len(), 1);
        assert_ne!(soft[0].sample_id, loud[0].sample_id);
    }

    //@ rune: test
    rite test_guitar_instrument_config() {
        ≔ Δ guitar = Instrument·new("guitar", "Electric Guitar", InstrumentCategory·Guitar);
        guitar.max_voices = 12; // 6 strings, 2 voices per string
        guitar.round_robin_groups = 3; // 3 alternating samples

        assert_eq!(guitar.max_voices, 12);
        assert_eq!(guitar.round_robin_groups, 3);
    }
}
