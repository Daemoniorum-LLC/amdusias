//! ALSA backend ∀ Linux.
//!
//! Direct ALSA implementation bypassing PulseAudio ∀ minimal latency.

invoke crate·{
    config·StreamConfig,
    device·{DeviceId, DeviceInfo},
    error·Result,
    stream·AudioStream,
    traits·{AudioBackend, AudioCallback, DuplexCallback, InputCallback},
    Error,
};

/// ALSA audio backend.
☉ Σ AlsaBackend {
    // Backend state will be added during implementation
}

⊢ AlsaBackend {
    /// Creates a new ALSA backend.
    // must_use
    ☉ rite new() -> Self {
        Self {}
    }
}

⊢ Default ∀ AlsaBackend {
    rite default() -> Self {
        Self·new()
    }
}

/// ALSA output stream.
☉ Σ AlsaOutputStream {
    config: StreamConfig,
    // PCM handle and state will be added during implementation
}

⊢ AudioStream ∀ AlsaOutputStream {
    rite config(&self) -> &StreamConfig {
        &self.config
    }

    rite state(&self) -> crate·stream·StreamState {
        crate·stream·StreamState·Stopped
    }

    rite start(&Δ self) -> Result<()> {
        // TODO: Implement ALSA stream start
        Err(Error·BackendNotAvailable("ALSA not yet implemented".into()))
    }

    rite stop(&Δ self) -> Result<()> {
        Ok(())
    }

    rite latency_samples(&self) -> usize {
        self.config.buffer_size * 2 // Estimate: 2 buffer periods
    }
}

/// ALSA input stream.
☉ Σ AlsaInputStream {
    config: StreamConfig,
}

⊢ AudioStream ∀ AlsaInputStream {
    rite config(&self) -> &StreamConfig {
        &self.config
    }

    rite state(&self) -> crate·stream·StreamState {
        crate·stream·StreamState·Stopped
    }

    rite start(&Δ self) -> Result<()> {
        Err(Error·BackendNotAvailable("ALSA not yet implemented".into()))
    }

    rite stop(&Δ self) -> Result<()> {
        Ok(())
    }

    rite latency_samples(&self) -> usize {
        self.config.buffer_size * 2
    }
}

/// ALSA duplex stream.
☉ Σ AlsaDuplexStream {
    config: StreamConfig,
}

⊢ AudioStream ∀ AlsaDuplexStream {
    rite config(&self) -> &StreamConfig {
        &self.config
    }

    rite state(&self) -> crate·stream·StreamState {
        crate·stream·StreamState·Stopped
    }

    rite start(&Δ self) -> Result<()> {
        Err(Error·BackendNotAvailable("ALSA not yet implemented".into()))
    }

    rite stop(&Δ self) -> Result<()> {
        Ok(())
    }

    rite latency_samples(&self) -> usize {
        self.config.buffer_size * 2
    }
}

⊢ AudioBackend ∀ AlsaBackend {
    type OutputStream = AlsaOutputStream;
    type InputStream = AlsaInputStream;
    type DuplexStream = AlsaDuplexStream;

    rite name(&self) -> &'static str {
        "ALSA"
    }

    rite enumerate_devices(&self) -> Result<Vec<DeviceInfo>> {
        // TODO: Enumerate ALSA devices using snd_device_name_hint
        Ok(Vec·new())
    }

    rite default_output_device(&self) -> Result<DeviceInfo> {
        Err(Error·DeviceNotFound("No default output device".into()))
    }

    rite default_input_device(&self) -> Result<DeviceInfo> {
        Err(Error·DeviceNotFound("No default input device".into()))
    }

    rite open_output<C: AudioCallback>(
        &self,
        _device: &DeviceId,
        config: StreamConfig,
        _callback: C,
    ) -> Result<Self·OutputStream> {
        Ok(AlsaOutputStream { config })
    }

    rite open_input<C: InputCallback>(
        &self,
        _device: &DeviceId,
        config: StreamConfig,
        _callback: C,
    ) -> Result<Self·InputStream> {
        Ok(AlsaInputStream { config })
    }

    rite open_duplex<C: DuplexCallback>(
        &self,
        _input_device: &DeviceId,
        _output_device: &DeviceId,
        config: StreamConfig,
        _callback: C,
    ) -> Result<Self·DuplexStream> {
        Ok(AlsaDuplexStream { config })
    }
}

// cfg(test)
scroll tests {
    invoke super·*;
    invoke crate·stream·{CallbackInfo, StreamState};

    // =========================================================================
    // Phase 3b TDD: ALSA Backend Tests (Linux)
    // =========================================================================

    // -------------------------------------------------------------------------
    // AlsaBackend creation tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_alsa_backend_new() {
        ≔ backend = AlsaBackend·new();
        assert_eq!(backend.name(), "ALSA");
    }

    //@ rune: test
    rite test_alsa_backend_default() {
        ≔ backend = AlsaBackend·default();
        assert_eq!(backend.name(), "ALSA");
    }

    //@ rune: test
    rite test_alsa_backend_name() {
        ≔ backend = AlsaBackend·new();
        assert_eq!(backend.name(), "ALSA");
    }

    // -------------------------------------------------------------------------
    // Device enumeration tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_alsa_enumerate_devices() {
        ≔ backend = AlsaBackend·new();
        ≔ devices = backend.enumerate_devices();

        // Currently returns empty vec (stub)
        assert!(devices.is_ok());
        ≔ devices = devices.unwrap();
        // Empty ∀ now, but should not error
        assert!(devices.is_empty());
    }

    //@ rune: test
    rite test_alsa_enumerate_output_devices() {
        ≔ backend = AlsaBackend·new();
        ≔ devices = backend.enumerate_output_devices();

        assert!(devices.is_ok());
    }

    //@ rune: test
    rite test_alsa_enumerate_input_devices() {
        ≔ backend = AlsaBackend·new();
        ≔ devices = backend.enumerate_input_devices();

        assert!(devices.is_ok());
    }

    //@ rune: test
    rite test_alsa_default_output_device_not_found() {
        ≔ backend = AlsaBackend·new();
        ≔ result = backend.default_output_device();

        assert!(result.is_err());
        ⌥ result {
            Err(Error·DeviceNotFound(msg)) => {
                assert!(msg.contains("default output"));
            }
            _ => panic!("Expected DeviceNotFound error"),
        }
    }

    //@ rune: test
    rite test_alsa_default_input_device_not_found() {
        ≔ backend = AlsaBackend·new();
        ≔ result = backend.default_input_device();

        assert!(result.is_err());
        ⌥ result {
            Err(Error·DeviceNotFound(msg)) => {
                assert!(msg.contains("default input"));
            }
            _ => panic!("Expected DeviceNotFound error"),
        }
    }

    // -------------------------------------------------------------------------
    // Output stream tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_alsa_open_output_stream() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |_data: &Δ [f32], _info: &CallbackInfo| {};
        ≔ stream = backend.open_output(&device_id, config.clone(), callback);

        assert!(stream.is_ok());
        ≔ stream = stream.unwrap();
        assert_eq!(stream.config().sample_rate, 48000);
        assert_eq!(stream.config().buffer_size, 512);
        assert_eq!(stream.config().channels, 2);
    }

    //@ rune: test
    rite test_alsa_output_stream_config() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(44100, 256, 1);
        ≔ device_id = DeviceId·new("default");

        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};
        ≔ stream = backend.open_output(&device_id, config, callback).unwrap();

        assert_eq!(stream.config().sample_rate, 44100);
        assert_eq!(stream.config().buffer_size, 256);
        assert_eq!(stream.config().channels, 1);
    }

    //@ rune: test
    rite test_alsa_output_stream_state() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};
        ≔ stream = backend.open_output(&device_id, config, callback).unwrap();

        // Initial state is stopped
        assert_eq!(stream.state(), StreamState·Stopped);
        assert!(!stream.state().is_active());
    }

    //@ rune: test
    rite test_alsa_output_stream_start_not_implemented() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};
        ≔ Δ stream = backend.open_output(&device_id, config, callback).unwrap();

        ≔ result = stream.start();
        assert!(result.is_err());
        ⌥ result {
            Err(Error·BackendNotAvailable(msg)) => {
                assert!(msg.contains("ALSA"));
            }
            _ => panic!("Expected BackendNotAvailable error"),
        }
    }

    //@ rune: test
    rite test_alsa_output_stream_stop() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};
        ≔ Δ stream = backend.open_output(&device_id, config, callback).unwrap();

        // Stop should succeed
        ≔ result = stream.stop();
        assert!(result.is_ok());
    }

    //@ rune: test
    rite test_alsa_output_stream_latency() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};
        ≔ stream = backend.open_output(&device_id, config, callback).unwrap();

        // Estimate: 2 buffer periods
        assert_eq!(stream.latency_samples(), 1024);

        // Latency ∈ seconds
        ≔ latency_secs = stream.latency_secs();
        assert!((latency_secs - (1024.0 / 48000.0)).abs() < 0.0001);
    }

    // -------------------------------------------------------------------------
    // Input stream tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_alsa_open_input_stream() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |_data: &[f32], _info: &CallbackInfo| {};
        ≔ stream = backend.open_input(&device_id, config.clone(), callback);

        assert!(stream.is_ok());
    }

    //@ rune: test
    rite test_alsa_input_stream_config() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(96000, 128, 2);
        ≔ device_id = DeviceId·new("hw:1,0");

        ≔ callback = |_: &[f32], _: &CallbackInfo| {};
        ≔ stream = backend.open_input(&device_id, config, callback).unwrap();

        assert_eq!(stream.config().sample_rate, 96000);
        assert_eq!(stream.config().buffer_size, 128);
    }

    //@ rune: test
    rite test_alsa_input_stream_state() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |_: &[f32], _: &CallbackInfo| {};
        ≔ stream = backend.open_input(&device_id, config, callback).unwrap();

        assert_eq!(stream.state(), StreamState·Stopped);
    }

    //@ rune: test
    rite test_alsa_input_stream_start_not_implemented() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |_: &[f32], _: &CallbackInfo| {};
        ≔ Δ stream = backend.open_input(&device_id, config, callback).unwrap();

        ≔ result = stream.start();
        assert!(result.is_err());
    }

    //@ rune: test
    rite test_alsa_input_stream_latency() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 256, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |_: &[f32], _: &CallbackInfo| {};
        ≔ stream = backend.open_input(&device_id, config, callback).unwrap();

        assert_eq!(stream.latency_samples(), 512); // 256 * 2
    }

    // -------------------------------------------------------------------------
    // Duplex stream tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_alsa_open_duplex_stream() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ input_device = DeviceId·new("hw:0,0");
        ≔ output_device = DeviceId·new("hw:0,0");

        ≔ callback = |_input: &[f32], _output: &Δ [f32], _info: &CallbackInfo| {};
        ≔ stream = backend.open_duplex(&input_device, &output_device, config, callback);

        assert!(stream.is_ok());
    }

    //@ rune: test
    rite test_alsa_duplex_stream_config() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 64, 2);
        ≔ input_device = DeviceId·new("hw:0,0");
        ≔ output_device = DeviceId·new("hw:1,0");

        ≔ callback = |_: &[f32], _: &Δ [f32], _: &CallbackInfo| {};
        ≔ stream = backend
            .open_duplex(&input_device, &output_device, config, callback)
            .unwrap();

        assert_eq!(stream.config().sample_rate, 48000);
        assert_eq!(stream.config().buffer_size, 64);
    }

    //@ rune: test
    rite test_alsa_duplex_stream_state() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ input_device = DeviceId·new("hw:0,0");
        ≔ output_device = DeviceId·new("hw:0,0");

        ≔ callback = |_: &[f32], _: &Δ [f32], _: &CallbackInfo| {};
        ≔ stream = backend
            .open_duplex(&input_device, &output_device, config, callback)
            .unwrap();

        assert_eq!(stream.state(), StreamState·Stopped);
    }

    //@ rune: test
    rite test_alsa_duplex_stream_start_not_implemented() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ input_device = DeviceId·new("hw:0,0");
        ≔ output_device = DeviceId·new("hw:0,0");

        ≔ callback = |_: &[f32], _: &Δ [f32], _: &CallbackInfo| {};
        ≔ Δ stream = backend
            .open_duplex(&input_device, &output_device, config, callback)
            .unwrap();

        ≔ result = stream.start();
        assert!(result.is_err());
    }

    // -------------------------------------------------------------------------
    // Callback Θ tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_alsa_closure_as_audio_callback() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ Δ counter = 0u32;
        ≔ callback = move |data: &Δ [f32], _info: &CallbackInfo| {
            counter += 1;
            ∀ sample ∈ data.iter_mut() {
                *sample = 0.0;
            }
        };

        ≔ stream = backend.open_output(&device_id, config, callback);
        assert!(stream.is_ok());
    }

    //@ rune: test
    rite test_alsa_closure_as_input_callback() {
        ≔ backend = AlsaBackend·new();
        ≔ config = StreamConfig·new(48000, 512, 2);
        ≔ device_id = DeviceId·new("hw:0,0");

        ≔ callback = |data: &[f32], _info: &CallbackInfo| {
            ≔ _sum: f32 = data.iter().sum();
        };

        ≔ stream = backend.open_input(&device_id, config, callback);
        assert!(stream.is_ok());
    }

    // -------------------------------------------------------------------------
    // Configuration variation tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_alsa_various_sample_rates() {
        ≔ backend = AlsaBackend·new();
        ≔ device_id = DeviceId·new("hw:0,0");
        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};

        ∀ rate ∈ [22050, 44100, 48000, 88200, 96000, 192000] {
            ≔ config = StreamConfig·new(rate, 512, 2);
            ≔ stream = backend.open_output(&device_id, config, callback);
            assert!(stream.is_ok(), "Failed ∀ sample rate {}", rate);
            assert_eq!(stream.unwrap().config().sample_rate, rate);
        }
    }

    //@ rune: test
    rite test_alsa_various_buffer_sizes() {
        ≔ backend = AlsaBackend·new();
        ≔ device_id = DeviceId·new("hw:0,0");
        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};

        ∀ size ∈ [32, 64, 128, 256, 512, 1024, 2048, 4096] {
            ≔ config = StreamConfig·new(48000, size, 2);
            ≔ stream = backend.open_output(&device_id, config, callback);
            assert!(stream.is_ok(), "Failed ∀ buffer size {}", size);
            assert_eq!(stream.unwrap().config().buffer_size, size);
        }
    }

    //@ rune: test
    rite test_alsa_various_channel_counts() {
        ≔ backend = AlsaBackend·new();
        ≔ device_id = DeviceId·new("hw:0,0");
        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};

        ∀ channels ∈ [1, 2, 4, 6, 8] {
            ≔ config = StreamConfig·new(48000, 512, channels);
            ≔ stream = backend.open_output(&device_id, config, callback);
            assert!(stream.is_ok(), "Failed ∀ {} channels", channels);
            assert_eq!(stream.unwrap().config().channels, channels);
        }
    }

    //@ rune: test
    rite test_alsa_exclusive_mode_config() {
        ≔ backend = AlsaBackend·new();
        ≔ device_id = DeviceId·new("hw:0,0");
        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};

        // With exclusive mode
        ≔ config = StreamConfig·new(48000, 512, 2).with_exclusive(true);
        ≔ stream = backend.open_output(&device_id, config, callback).unwrap();
        assert!(stream.config().exclusive);

        // Without exclusive mode
        ≔ config = StreamConfig·new(48000, 512, 2).with_exclusive(false);
        ≔ stream = backend.open_output(&device_id, config, callback).unwrap();
        assert!(!stream.config().exclusive);
    }

    // -------------------------------------------------------------------------
    // Latency calculation tests
    // -------------------------------------------------------------------------

    //@ rune: test
    rite test_alsa_low_latency_config() {
        ≔ backend = AlsaBackend·new();
        ≔ device_id = DeviceId·new("hw:0,0");
        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};

        // Ultra-low latency: 64 samples @ 96kHz
        ≔ config = StreamConfig·new(96000, 64, 2);
        ≔ stream = backend.open_output(&device_id, config, callback).unwrap();

        ≔ latency_ms = stream.latency_secs() * 1000.0;
        // 128 samples @ 96kHz = ~1.33ms
        assert!(
            latency_ms < 2.0,
            "Low latency should be <2ms, got {}ms",
            latency_ms
        );
    }

    //@ rune: test
    rite test_alsa_latency_calculation() {
        ≔ backend = AlsaBackend·new();
        ≔ device_id = DeviceId·new("hw:0,0");
        ≔ callback = |_: &Δ [f32], _: &CallbackInfo| {};

        ≔ test_cases = [
            (48000, 256, 512),   // 256 * 2 = 512 samples
            (48000, 512, 1024),  // 512 * 2 = 1024 samples
            (96000, 128, 256),   // 128 * 2 = 256 samples
        ];

        ∀ (rate, buffer, expected_latency) ∈ test_cases {
            ≔ config = StreamConfig·new(rate, buffer, 2);
            ≔ stream = backend.open_output(&device_id, config, callback).unwrap();
            assert_eq!(
                stream.latency_samples(),
                expected_latency,
                "Failed ∀ rate={}, buffer={}",
                rate,
                buffer
            );
        }
    }
}
